        -:    0:Source:memcached.c
        -:    0:Graph:memcached.gcno
        -:    0:Data:memcached.gcda
        -:    0:Runs:167
        -:    0:Programs:1
        -:    1:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    2:/*
        -:    3: *  memcached - memory caching daemon
        -:    4: *
        -:    5: *       http://www.memcached.org/
        -:    6: *
        -:    7: *  Copyright 2003 Danga Interactive, Inc.  All rights reserved.
        -:    8: *
        -:    9: *  Use and distribution licensed under the BSD license.  See
        -:   10: *  the LICENSE file for full text.
        -:   11: *
        -:   12: *  Authors:
        -:   13: *      Anatoly Vorobey <mellon@pobox.com>
        -:   14: *      Brad Fitzpatrick <brad@danga.com>
        -:   15: */
        -:   16:#include "memcached.h"
        -:   17:#include <sys/stat.h>
        -:   18:#include <sys/socket.h>
        -:   19:#include <sys/un.h>
        -:   20:#include <signal.h>
        -:   21:#include <sys/param.h>
        -:   22:#include <sys/resource.h>
        -:   23:#include <sys/uio.h>
        -:   24:#include <ctype.h>
        -:   25:#include <stdarg.h>
        -:   26:
        -:   27:/* some POSIX systems need the following definition
        -:   28: * to get mlockall flags out of sys/mman.h.  */
        -:   29:#ifndef _P1003_1B_VISIBLE
        -:   30:#define _P1003_1B_VISIBLE
        -:   31:#endif
        -:   32:/* need this to get IOV_MAX on some platforms. */
        -:   33:#ifndef __need_IOV_MAX
        -:   34:#define __need_IOV_MAX
        -:   35:#endif
        -:   36:#include <pwd.h>
        -:   37:#include <sys/mman.h>
        -:   38:#include <fcntl.h>
        -:   39:#include <netinet/tcp.h>
        -:   40:#include <arpa/inet.h>
        -:   41:#include <errno.h>
        -:   42:#include <stdlib.h>
        -:   43:#include <stdio.h>
        -:   44:#include <string.h>
        -:   45:#include <time.h>
        -:   46:#include <assert.h>
        -:   47:#include <limits.h>
        -:   48:#include <sysexits.h>
        -:   49:#include <stddef.h>
        -:   50:
        -:   51:/* FreeBSD 4.x doesn't have IOV_MAX exposed. */
        -:   52:#ifndef IOV_MAX
        -:   53:#if defined(__FreeBSD__) || defined(__APPLE__)
        -:   54:# define IOV_MAX 1024
        -:   55:#endif
        -:   56:#endif
        -:   57:
        -:   58:/*
        -:   59: * forward declarations
        -:   60: */
        -:   61:static void drive_machine(conn *c);
        -:   62:static int new_socket(struct addrinfo *ai);
        -:   63:static int try_read_command(conn *c);
        -:   64:
        -:   65:enum try_read_result {
        -:   66:    READ_DATA_RECEIVED,
        -:   67:    READ_NO_DATA_RECEIVED,
        -:   68:    READ_ERROR,            /** an error occurred (on the socket) (or client closed connection) */
        -:   69:    READ_MEMORY_ERROR      /** failed to allocate more memory */
        -:   70:};
        -:   71:
        -:   72:static enum try_read_result try_read_network(conn *c);
        -:   73:static enum try_read_result try_read_udp(conn *c);
        -:   74:
        -:   75:static void conn_set_state(conn *c, enum conn_states state);
        -:   76:
        -:   77:/* stats */
        -:   78:static void stats_init(void);
        -:   79:static void server_stats(ADD_STAT add_stats, conn *c);
        -:   80:static void process_stat_settings(ADD_STAT add_stats, void *c);
        -:   81:static void conn_to_str(const conn *c, char *buf);
        -:   82:
        -:   83:
        -:   84:/* defaults */
        -:   85:static void settings_init(void);
        -:   86:
        -:   87:/* event handling, network IO */
        -:   88:static void event_handler(const int fd, const short which, void *arg);
        -:   89:static void conn_close(conn *c);
        -:   90:static void conn_init(void);
        -:   91:static bool update_event(conn *c, const int new_flags);
        -:   92:static void complete_nread(conn *c);
        -:   93:static void process_command(conn *c, char *command);
        -:   94:static void write_and_free(conn *c, char *buf, int bytes);
        -:   95:static int ensure_iov_space(conn *c);
        -:   96:static int add_iov(conn *c, const void *buf, int len);
        -:   97:static int add_msghdr(conn *c);
        -:   98:static void write_bin_error(conn *c, protocol_binary_response_status err,
        -:   99:                            const char *errstr, int swallow);
        -:  100:
        -:  101:static void conn_free(conn *c);
        -:  102:
        -:  103:/** exported globals **/
        -:  104:struct stats stats;
        -:  105:struct settings settings;
        -:  106:time_t process_started;     /* when the process was started */
        -:  107:conn **conns;
        -:  108:
        -:  109:struct slab_rebalance slab_rebal;
        -:  110:volatile int slab_rebalance_signal;
        -:  111:
        -:  112:/** file scope variables **/
        -:  113:static conn *listen_conn = NULL;
        -:  114:static int max_fds;
        -:  115:static struct event_base *main_base;
        -:  116:
        -:  117:enum transmit_result {
        -:  118:    TRANSMIT_COMPLETE,   /** All done writing. */
        -:  119:    TRANSMIT_INCOMPLETE, /** More data remaining to write. */
        -:  120:    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */
        -:  121:    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */
        -:  122:};
        -:  123:
        -:  124:static enum transmit_result transmit(conn *c);
        -:  125:
        -:  126:/* This reduces the latency without adding lots of extra wiring to be able to
        -:  127: * notify the listener thread of when to listen again.
        -:  128: * Also, the clock timer could be broken out into its own thread and we
        -:  129: * can block the listener via a condition.
        -:  130: */
        -:  131:static volatile bool allow_new_conns = true;
        -:  132:static struct event maxconnsevent;
    #####:  133:static void maxconns_handler(const int fd, const short which, void *arg) {
    #####:  134:    struct timeval t = {.tv_sec = 0, .tv_usec = 10000};
        -:  135:
    #####:  136:    if (fd == -42 || allow_new_conns == false) {
        -:  137:        /* reschedule in 10ms if we need to keep polling */
    #####:  138:        evtimer_set(&maxconnsevent, maxconns_handler, 0);
    #####:  139:        event_base_set(main_base, &maxconnsevent);
    #####:  140:        evtimer_add(&maxconnsevent, &t);
        -:  141:    } else {
    #####:  142:        evtimer_del(&maxconnsevent);
    #####:  143:        accept_new_conns(true);
        -:  144:    }
    #####:  145:}
        -:  146:
        -:  147:#define REALTIME_MAXDELTA 60*60*24*30
        -:  148:
        -:  149:/*
        -:  150: * given time value that's either unix time or delta from current unix time, return
        -:  151: * unix time. Use the fact that delta can't exceed one month (and real time value can't
        -:  152: * be that low).
        -:  153: */
        -:  154:static rel_time_t realtime(const time_t exptime) {
        -:  155:    /* no. of seconds in 30 days - largest possible delta exptime */
        -:  156:
    53003:  157:    if (exptime == 0) return 0; /* 0 means never expire */
        -:  158:
      407:  159:    if (exptime > REALTIME_MAXDELTA) {
        -:  160:        /* if item expiration is at/before the server started, give it an
        -:  161:           expiration time of 1 second after the server started.
        -:  162:           (because 0 means don't expire).  without this, we'd
        -:  163:           underflow and wrap around to some large value way in the
        -:  164:           future, effectively making items expiring in the past
        -:  165:           really expiring never */
        5:  166:        if (exptime <= process_started)
        -:  167:            return (rel_time_t)1;
        4:  168:        return (rel_time_t)(exptime - process_started);
        -:  169:    } else {
      402:  170:        return (rel_time_t)(exptime + current_time);
        -:  171:    }
        -:  172:}
        -:  173:
       83:  174:static void stats_init(void) {
       83:  175:    stats.curr_items = stats.total_items = stats.curr_conns = stats.total_conns = stats.conn_structs = 0;
       83:  176:    stats.get_cmds = stats.set_cmds = stats.get_hits = stats.get_misses = stats.evictions = stats.reclaimed = 0;
       83:  177:    stats.touch_cmds = stats.touch_misses = stats.touch_hits = stats.rejected_conns = 0;
       83:  178:    stats.malloc_fails = 0;
       83:  179:    stats.curr_bytes = stats.listen_disabled_num = 0;
       83:  180:    stats.hash_power_level = stats.hash_bytes = stats.hash_is_expanding = 0;
       83:  181:    stats.expired_unfetched = stats.evicted_unfetched = 0;
       83:  182:    stats.slabs_moved = 0;
       83:  183:    stats.lru_maintainer_juggles = 0;
       83:  184:    stats.accepting_conns = true; /* assuming we start in this state. */
       83:  185:    stats.slab_reassign_running = false;
       83:  186:    stats.lru_crawler_running = false;
       83:  187:    stats.lru_crawler_starts = 0;
       83:  188:    stats.time_in_listen_disabled_us = 0;
        -:  189:
        -:  190:    /* make the time we started always be 2 seconds before we really
        -:  191:       did, so time(0) - time.started is never zero.  if so, things
        -:  192:       like 'settings.oldest_live' which act as booleans as well as
        -:  193:       values are now false in boolean context... */
       83:  194:    process_started = time(0) - ITEM_UPDATE_INTERVAL - 2;
       83:  195:    stats_prefix_init();
       83:  196:}
        -:  197:
        3:  198:static void stats_reset(void) {
        3:  199:    STATS_LOCK();
        3:  200:    stats.total_items = stats.total_conns = 0;
        3:  201:    stats.rejected_conns = 0;
        3:  202:    stats.malloc_fails = 0;
        3:  203:    stats.evictions = 0;
        3:  204:    stats.reclaimed = 0;
        3:  205:    stats.listen_disabled_num = 0;
        3:  206:    stats_prefix_clear();
        3:  207:    STATS_UNLOCK();
        3:  208:    threadlocal_stats_reset();
        3:  209:    item_stats_reset();
        3:  210:}
        -:  211:
      166:  212:static void settings_init(void) {
      166:  213:    settings.use_cas = true;
      166:  214:    settings.access = 0700;
      166:  215:    settings.port = 11211;
      166:  216:    settings.udpport = 11211;
        -:  217:    /* By default this string should be NULL for getaddrinfo() */
      166:  218:    settings.inter = NULL;
      166:  219:    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */
      166:  220:    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */
      166:  221:    settings.verbose = 0;
      166:  222:    settings.oldest_live = 0;
      166:  223:    settings.oldest_cas = 0;          /* supplements accuracy of oldest_live */
      166:  224:    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */
      166:  225:    settings.socketpath = NULL;       /* by default, not using a unix socket */
      166:  226:    settings.factor = 1.25;
      166:  227:    settings.chunk_size = 48;         /* space for a modest key and value */
      166:  228:    settings.num_threads = 4;         /* N workers */
      166:  229:    settings.num_threads_per_udp = 0;
      166:  230:    settings.prefix_delimiter = ':';
      166:  231:    settings.detail_enabled = 0;
      166:  232:    settings.reqs_per_event = 20;
      166:  233:    settings.backlog = 1024;
      166:  234:    settings.binding_protocol = negotiating_prot;
      166:  235:    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */
      166:  236:    settings.maxconns_fast = false;
      166:  237:    settings.lru_crawler = false;
      166:  238:    settings.lru_crawler_sleep = 100;
      166:  239:    settings.lru_crawler_tocrawl = 0;
      166:  240:    settings.lru_maintainer_thread = false;
      166:  241:    settings.hot_lru_pct = 32;
      166:  242:    settings.warm_lru_pct = 32;
      166:  243:    settings.expirezero_does_not_evict = false;
      166:  244:    settings.hashpower_init = 0;
      166:  245:    settings.slab_reassign = false;
      166:  246:    settings.slab_automove = 0;
      166:  247:    settings.shutdown_command = false;
      166:  248:    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;
      166:  249:    settings.flush_enabled = true;
      166:  250:    settings.crawls_persleep = 1000;
      166:  251:}
        -:  252:
        -:  253:/*
        -:  254: * Adds a message header to a connection.
        -:  255: *
        -:  256: * Returns 0 on success, -1 on out-of-memory.
        -:  257: */
    82636:  258:static int add_msghdr(conn *c)
        -:  259:{
        -:  260:    struct msghdr *msg;
        -:  261:
    82636:  262:    assert(c != NULL);
        -:  263:
    82636:  264:    if (c->msgsize == c->msgused) {
    #####:  265:        msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));
    #####:  266:        if (! msg) {
    #####:  267:            STATS_LOCK();
    #####:  268:            stats.malloc_fails++;
    #####:  269:            STATS_UNLOCK();
    #####:  270:            return -1;
        -:  271:        }
    #####:  272:        c->msglist = msg;
    #####:  273:        c->msgsize *= 2;
        -:  274:    }
        -:  275:
    82636:  276:    msg = c->msglist + c->msgused;
        -:  277:
        -:  278:    /* this wipes msg_iovlen, msg_control, msg_controllen, and
        -:  279:       msg_flags, the last 3 of which aren't defined on solaris: */
        -:  280:    memset(msg, 0, sizeof(struct msghdr));
        -:  281:
    82636:  282:    msg->msg_iov = &c->iov[c->iovused];
        -:  283:
    82636:  284:    if (IS_UDP(c->transport) && c->request_addr_size > 0) {
       29:  285:        msg->msg_name = &c->request_addr;
       29:  286:        msg->msg_namelen = c->request_addr_size;
        -:  287:    }
        -:  288:
    82636:  289:    c->msgbytes = 0;
    82636:  290:    c->msgused++;
        -:  291:
    82636:  292:    if (IS_UDP(c->transport)) {
        -:  293:        /* Leave room for the UDP header, which we'll fill in later. */
       29:  294:        return add_iov(c, NULL, UDP_HEADER_SIZE);
        -:  295:    }
        -:  296:
        -:  297:    return 0;
        -:  298:}
        -:  299:
        -:  300:extern pthread_mutex_t conn_lock;
        -:  301:
        -:  302:/*
        -:  303: * Initializes the connections array. We don't actually allocate connection
        -:  304: * structures until they're needed, so as to avoid wasting memory when the
        -:  305: * maximum connection count is much higher than the actual number of
        -:  306: * connections.
        -:  307: *
        -:  308: * This does end up wasting a few pointers' worth of memory for FDs that are
        -:  309: * used for things other than connections, but that's worth it in exchange for
        -:  310: * being able to directly index the conns array by FD.
        -:  311: */
       83:  312:static void conn_init(void) {
        -:  313:    /* We're unlikely to see an FD much higher than maxconns. */
       83:  314:    int next_fd = dup(1);
       83:  315:    int headroom = 10;      /* account for extra unexpected open FDs */
        -:  316:    struct rlimit rl;
        -:  317:
       83:  318:    max_fds = settings.maxconns + headroom + next_fd;
        -:  319:
        -:  320:    /* But if possible, get the actual highest FD we can possibly ever see. */
       83:  321:    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
       83:  322:        max_fds = rl.rlim_max;
        -:  323:    } else {
    #####:  324:        fprintf(stderr, "Failed to query maximum file descriptor; "
        -:  325:                        "falling back to maxconns\n");
        -:  326:    }
        -:  327:
       83:  328:    close(next_fd);
        -:  329:
       83:  330:    if ((conns = calloc(max_fds, sizeof(conn *))) == NULL) {
    #####:  331:        fprintf(stderr, "Failed to allocate connection structures\n");
        -:  332:        /* This is unrecoverable so bail out early. */
    #####:  333:        exit(1);
        -:  334:    }
       83:  335:}
        -:  336:
        -:  337:static const char *prot_text(enum protocol prot) {
       22:  338:    char *rv = "unknown";
        -:  339:    switch(prot) {
        -:  340:        case ascii_prot:
        -:  341:            rv = "ascii";
        -:  342:            break;
        -:  343:        case binary_prot:
        -:  344:            rv = "binary";
        -:  345:            break;
        -:  346:        case negotiating_prot:
        -:  347:            rv = "auto-negotiate";
        -:  348:            break;
        -:  349:    }
        -:  350:    return rv;
        -:  351:}
        -:  352:
      838:  353:conn *conn_new(const int sfd, enum conn_states init_state,
        -:  354:                const int event_flags,
        -:  355:                const int read_buffer_size, enum network_transport transport,
        -:  356:                struct event_base *base) {
        -:  357:    conn *c;
        -:  358:
      838:  359:    assert(sfd >= 0 && sfd < max_fds);
      838:  360:    c = conns[sfd];
        -:  361:
      838:  362:    if (NULL == c) {
      831:  363:        if (!(c = (conn *)calloc(1, sizeof(conn)))) {
    #####:  364:            STATS_LOCK();
    #####:  365:            stats.malloc_fails++;
    #####:  366:            STATS_UNLOCK();
    #####:  367:            fprintf(stderr, "Failed to allocate connection object\n");
    #####:  368:            return NULL;
        -:  369:        }
        -:  370:        MEMCACHED_CONN_CREATE(c);
        -:  371:
      831:  372:        c->rbuf = c->wbuf = 0;
      831:  373:        c->ilist = 0;
      831:  374:        c->suffixlist = 0;
      831:  375:        c->iov = 0;
      831:  376:        c->msglist = 0;
      831:  377:        c->hdrbuf = 0;
        -:  378:
      831:  379:        c->rsize = read_buffer_size;
      831:  380:        c->wsize = DATA_BUFFER_SIZE;
      831:  381:        c->isize = ITEM_LIST_INITIAL;
      831:  382:        c->suffixsize = SUFFIX_LIST_INITIAL;
      831:  383:        c->iovsize = IOV_LIST_INITIAL;
      831:  384:        c->msgsize = MSG_LIST_INITIAL;
      831:  385:        c->hdrsize = 0;
        -:  386:
      831:  387:        c->rbuf = (char *)malloc((size_t)c->rsize);
      831:  388:        c->wbuf = (char *)malloc((size_t)c->wsize);
      831:  389:        c->ilist = (item **)malloc(sizeof(item *) * c->isize);
      831:  390:        c->suffixlist = (char **)malloc(sizeof(char *) * c->suffixsize);
      831:  391:        c->iov = (struct iovec *)malloc(sizeof(struct iovec) * c->iovsize);
      831:  392:        c->msglist = (struct msghdr *)malloc(sizeof(struct msghdr) * c->msgsize);
        -:  393:
      831:  394:        if (c->rbuf == 0 || c->wbuf == 0 || c->ilist == 0 || c->iov == 0 ||
      831:  395:                c->msglist == 0 || c->suffixlist == 0) {
    #####:  396:            conn_free(c);
    #####:  397:            STATS_LOCK();
    #####:  398:            stats.malloc_fails++;
    #####:  399:            STATS_UNLOCK();
    #####:  400:            fprintf(stderr, "Failed to allocate buffers for connection\n");
    #####:  401:            return NULL;
        -:  402:        }
        -:  403:
      831:  404:        STATS_LOCK();
      831:  405:        stats.conn_structs++;
      831:  406:        STATS_UNLOCK();
        -:  407:
      831:  408:        c->sfd = sfd;
      831:  409:        conns[sfd] = c;
        -:  410:    }
        -:  411:
      838:  412:    c->transport = transport;
      838:  413:    c->protocol = settings.binding_protocol;
        -:  414:
        -:  415:    /* unix socket mode doesn't need this, so zeroed out.  but why
        -:  416:     * is this done for every command?  presumably for UDP
        -:  417:     * mode.  */
      838:  418:    if (!settings.socketpath) {
      833:  419:        c->request_addr_size = sizeof(c->request_addr);
        -:  420:    } else {
        5:  421:        c->request_addr_size = 0;
        -:  422:    }
        -:  423:
      838:  424:    if (transport == tcp_transport && init_state == conn_new_cmd) {
       93:  425:        if (getpeername(sfd, (struct sockaddr *) &c->request_addr,
        -:  426:                        &c->request_addr_size)) {
    #####:  427:            perror("getpeername");
    #####:  428:            memset(&c->request_addr, 0, sizeof(c->request_addr));
        -:  429:        }
        -:  430:    }
        -:  431:
      838:  432:    if (settings.verbose > 1) {
       30:  433:        if (init_state == conn_listening) {
       12:  434:            fprintf(stderr, "<%d server listening (%s)\n", sfd,
        -:  435:                prot_text(c->protocol));
       24:  436:        } else if (IS_UDP(transport)) {
       24:  437:            fprintf(stderr, "<%d server listening (udp)\n", sfd);
    #####:  438:        } else if (c->protocol == negotiating_prot) {
    #####:  439:            fprintf(stderr, "<%d new auto-negotiating client connection\n",
        -:  440:                    sfd);
    #####:  441:        } else if (c->protocol == ascii_prot) {
    #####:  442:            fprintf(stderr, "<%d new ascii client connection.\n", sfd);
    #####:  443:        } else if (c->protocol == binary_prot) {
    #####:  444:            fprintf(stderr, "<%d new binary client connection.\n", sfd);
        -:  445:        } else {
    #####:  446:            fprintf(stderr, "<%d new unknown (%d) client connection\n",
        -:  447:                sfd, c->protocol);
    #####:  448:            assert(false);
        -:  449:        }
        -:  450:    }
        -:  451:
      838:  452:    c->state = init_state;
      838:  453:    c->rlbytes = 0;
      838:  454:    c->cmd = -1;
      838:  455:    c->rbytes = c->wbytes = 0;
      838:  456:    c->wcurr = c->wbuf;
      838:  457:    c->rcurr = c->rbuf;
      838:  458:    c->ritem = 0;
      838:  459:    c->icurr = c->ilist;
      838:  460:    c->suffixcurr = c->suffixlist;
      838:  461:    c->ileft = 0;
      838:  462:    c->suffixleft = 0;
      838:  463:    c->iovused = 0;
      838:  464:    c->msgcurr = 0;
      838:  465:    c->msgused = 0;
      838:  466:    c->authenticated = false;
        -:  467:
      838:  468:    c->write_and_go = init_state;
      838:  469:    c->write_and_free = 0;
      838:  470:    c->item = 0;
        -:  471:
      838:  472:    c->noreply = false;
        -:  473:
      838:  474:    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);
      838:  475:    event_base_set(base, &c->event);
      838:  476:    c->ev_flags = event_flags;
        -:  477:
      838:  478:    if (event_add(&c->event, 0) == -1) {
    #####:  479:        perror("event_add");
    #####:  480:        return NULL;
        -:  481:    }
        -:  482:
      838:  483:    STATS_LOCK();
      838:  484:    stats.curr_conns++;
      838:  485:    stats.total_conns++;
      838:  486:    STATS_UNLOCK();
        -:  487:
        -:  488:    MEMCACHED_CONN_ALLOCATE(c->sfd);
        -:  489:
      838:  490:    return c;
        -:  491:}
        -:  492:
    10239:  493:static void conn_release_items(conn *c) {
    10239:  494:    assert(c != NULL);
        -:  495:
    10239:  496:    if (c->item) {
      592:  497:        item_remove(c->item);
      592:  498:        c->item = 0;
        -:  499:    }
        -:  500:
    16036:  501:    while (c->ileft > 0) {
     5797:  502:        item *it = *(c->icurr);
     5797:  503:        assert((it->it_flags & ITEM_SLABBED) == 0);
     5797:  504:        item_remove(it);
     5797:  505:        c->icurr++;
     5797:  506:        c->ileft--;
        -:  507:    }
        -:  508:
    10239:  509:    if (c->suffixleft != 0) {
       17:  510:        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {
       17:  511:            cache_free(c->thread->suffix_cache, *(c->suffixcurr));
        -:  512:        }
        -:  513:    }
        -:  514:
    10239:  515:    c->icurr = c->ilist;
    10239:  516:    c->suffixcurr = c->suffixlist;
    10239:  517:}
        -:  518:
       35:  519:static void conn_cleanup(conn *c) {
       35:  520:    assert(c != NULL);
        -:  521:
       35:  522:    conn_release_items(c);
        -:  523:
       35:  524:    if (c->write_and_free) {
    #####:  525:        free(c->write_and_free);
    #####:  526:        c->write_and_free = 0;
        -:  527:    }
        -:  528:
       35:  529:    if (c->sasl_conn) {
    #####:  530:        assert(settings.sasl);
        -:  531:        sasl_dispose(&c->sasl_conn);
    #####:  532:        c->sasl_conn = NULL;
        -:  533:    }
        -:  534:
       35:  535:    if (IS_UDP(c->transport)) {
    #####:  536:        conn_set_state(c, conn_read);
        -:  537:    }
       35:  538:}
        -:  539:
        -:  540:/*
        -:  541: * Frees a connection.
        -:  542: */
    #####:  543:void conn_free(conn *c) {
    #####:  544:    if (c) {
    #####:  545:        assert(c != NULL);
    #####:  546:        assert(c->sfd >= 0 && c->sfd < max_fds);
        -:  547:
        -:  548:        MEMCACHED_CONN_DESTROY(c);
    #####:  549:        conns[c->sfd] = NULL;
    #####:  550:        if (c->hdrbuf)
    #####:  551:            free(c->hdrbuf);
    #####:  552:        if (c->msglist)
    #####:  553:            free(c->msglist);
    #####:  554:        if (c->rbuf)
    #####:  555:            free(c->rbuf);
    #####:  556:        if (c->wbuf)
    #####:  557:            free(c->wbuf);
    #####:  558:        if (c->ilist)
    #####:  559:            free(c->ilist);
    #####:  560:        if (c->suffixlist)
    #####:  561:            free(c->suffixlist);
    #####:  562:        if (c->iov)
    #####:  563:            free(c->iov);
    #####:  564:        free(c);
        -:  565:    }
    #####:  566:}
        -:  567:
       35:  568:static void conn_close(conn *c) {
       35:  569:    assert(c != NULL);
        -:  570:
        -:  571:    /* delete the event, the socket and the conn */
       35:  572:    event_del(&c->event);
        -:  573:
       35:  574:    if (settings.verbose > 1)
    #####:  575:        fprintf(stderr, "<%d connection closed.\n", c->sfd);
        -:  576:
       35:  577:    conn_cleanup(c);
        -:  578:
        -:  579:    MEMCACHED_CONN_RELEASE(c->sfd);
       35:  580:    conn_set_state(c, conn_closed);
       35:  581:    close(c->sfd);
        -:  582:
       34:  583:    pthread_mutex_lock(&conn_lock);
       34:  584:    allow_new_conns = true;
       34:  585:    pthread_mutex_unlock(&conn_lock);
        -:  586:
       34:  587:    STATS_LOCK();
       34:  588:    stats.curr_conns--;
       34:  589:    STATS_UNLOCK();
        -:  590:
       34:  591:    return;
        -:  592:}
        -:  593:
        -:  594:/*
        -:  595: * Shrinks a connection's buffers if they're too big.  This prevents
        -:  596: * periodic large "get" requests from permanently chewing lots of server
        -:  597: * memory.
        -:  598: *
        -:  599: * This should only be called in between requests since it can wipe output
        -:  600: * buffers!
        -:  601: */
    69834:  602:static void conn_shrink(conn *c) {
    69834:  603:    assert(c != NULL);
        -:  604:
    69834:  605:    if (IS_UDP(c->transport))
    69834:  606:        return;
        -:  607:
    69817:  608:    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {
        -:  609:        char *newbuf;
        -:  610:
     7707:  611:        if (c->rcurr != c->rbuf)
     7707:  612:            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);
        -:  613:
     7707:  614:        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);
        -:  615:
     7707:  616:        if (newbuf) {
     7707:  617:            c->rbuf = newbuf;
     7707:  618:            c->rsize = DATA_BUFFER_SIZE;
        -:  619:        }
        -:  620:        /* TODO check other branch... */
     7707:  621:        c->rcurr = c->rbuf;
        -:  622:    }
        -:  623:
    69817:  624:    if (c->isize > ITEM_LIST_HIGHWAT) {
    #####:  625:        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));
    #####:  626:        if (newbuf) {
    #####:  627:            c->ilist = newbuf;
    #####:  628:            c->isize = ITEM_LIST_INITIAL;
        -:  629:        }
        -:  630:    /* TODO check error condition? */
        -:  631:    }
        -:  632:
    69817:  633:    if (c->msgsize > MSG_LIST_HIGHWAT) {
    #####:  634:        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));
    #####:  635:        if (newbuf) {
    #####:  636:            c->msglist = newbuf;
    #####:  637:            c->msgsize = MSG_LIST_INITIAL;
        -:  638:        }
        -:  639:    /* TODO check error condition? */
        -:  640:    }
        -:  641:
    69817:  642:    if (c->iovsize > IOV_LIST_HIGHWAT) {
    #####:  643:        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));
    #####:  644:        if (newbuf) {
    #####:  645:            c->iov = newbuf;
    #####:  646:            c->iovsize = IOV_LIST_INITIAL;
        -:  647:        }
        -:  648:    /* TODO check return value */
        -:  649:    }
        -:  650:}
        -:  651:
        -:  652:/**
        -:  653: * Convert a state name to a human readable form.
        -:  654: */
        -:  655:static const char *state_text(enum conn_states state) {
       14:  656:    const char* const statenames[] = { "conn_listening",
        -:  657:                                       "conn_new_cmd",
        -:  658:                                       "conn_waiting",
        -:  659:                                       "conn_read",
        -:  660:                                       "conn_parse_cmd",
        -:  661:                                       "conn_write",
        -:  662:                                       "conn_nread",
        -:  663:                                       "conn_swallow",
        -:  664:                                       "conn_closing",
        -:  665:                                       "conn_mwrite",
        -:  666:                                       "conn_closed" };
       14:  667:    return statenames[state];
        -:  668:}
        -:  669:
        -:  670:/*
        -:  671: * Sets a connection's current state in the state machine. Any special
        -:  672: * processing that needs to happen on certain state transitions can
        -:  673: * happen here.
        -:  674: */
   263198:  675:static void conn_set_state(conn *c, enum conn_states state) {
   263198:  676:    assert(c != NULL);
   263198:  677:    assert(state >= conn_listening && state < conn_max_state);
        -:  678:
   263198:  679:    if (state != c->state) {
   243069:  680:        if (settings.verbose > 2) {
    #####:  681:            fprintf(stderr, "%d: going from %s to %s\n",
        -:  682:                    c->sfd, state_text(c->state),
        -:  683:                    state_text(state));
        -:  684:        }
        -:  685:
        -:  686:        if (state == conn_write || state == conn_mwrite) {
        -:  687:            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);
        -:  688:        }
   243069:  689:        c->state = state;
        -:  690:    }
   263198:  691:}
        -:  692:
        -:  693:/*
        -:  694: * Ensures that there is room for another struct iovec in a connection's
        -:  695: * iov list.
        -:  696: *
        -:  697: * Returns 0 on success, -1 on out-of-memory.
        -:  698: */
    50102:  699:static int ensure_iov_space(conn *c) {
    50102:  700:    assert(c != NULL);
        -:  701:
    50102:  702:    if (c->iovused >= c->iovsize) {
        -:  703:        int i, iovnum;
    #####:  704:        struct iovec *new_iov = (struct iovec *)realloc(c->iov,
    #####:  705:                                (c->iovsize * 2) * sizeof(struct iovec));
    #####:  706:        if (! new_iov) {
    #####:  707:            STATS_LOCK();
    #####:  708:            stats.malloc_fails++;
    #####:  709:            STATS_UNLOCK();
    #####:  710:            return -1;
        -:  711:        }
    #####:  712:        c->iov = new_iov;
    #####:  713:        c->iovsize *= 2;
        -:  714:
        -:  715:        /* Point all the msghdr structures at the new list. */
    #####:  716:        for (i = 0, iovnum = 0; i < c->msgused; i++) {
    #####:  717:            c->msglist[i].msg_iov = &c->iov[iovnum];
    #####:  718:            iovnum += c->msglist[i].msg_iovlen;
        -:  719:        }
        -:  720:    }
        -:  721:
        -:  722:    return 0;
        -:  723:}
        -:  724:
        -:  725:
        -:  726:/*
        -:  727: * Adds data to the list of pending data that will be written out to a
        -:  728: * connection.
        -:  729: *
        -:  730: * Returns 0 on success, -1 on out-of-memory.
        -:  731: */
        -:  732:
    39464:  733:static int add_iov(conn *c, const void *buf, int len) {
        -:  734:    struct msghdr *m;
        -:  735:    int leftover;
        -:  736:    bool limit_to_mtu;
        -:  737:
    39464:  738:    assert(c != NULL);
        -:  739:
        -:  740:    do {
    50102:  741:        m = &c->msglist[c->msgused - 1];
        -:  742:
        -:  743:        /*
        -:  744:         * Limit UDP packets, and the first payloads of TCP replies, to
        -:  745:         * UDP_MAX_PAYLOAD_SIZE bytes.
        -:  746:         */
    50102:  747:        limit_to_mtu = IS_UDP(c->transport) || (1 == c->msgused);
        -:  748:
        -:  749:        /* We may need to start a new msghdr if this one is full. */
    50102:  750:        if (m->msg_iovlen == IOV_MAX ||
    39589:  751:            (limit_to_mtu && c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {
     5430:  752:            add_msghdr(c);
     5430:  753:            m = &c->msglist[c->msgused - 1];
        -:  754:        }
        -:  755:
    50102:  756:        if (ensure_iov_space(c) != 0)
        -:  757:            return -1;
        -:  758:
        -:  759:        /* If the fragment is too big to fit in the datagram, split it up */
    50102:  760:        if (limit_to_mtu && len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {
    10638:  761:            leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;
    10638:  762:            len -= leftover;
        -:  763:        } else {
        -:  764:            leftover = 0;
        -:  765:        }
        -:  766:
    50102:  767:        m = &c->msglist[c->msgused - 1];
    50102:  768:        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;
    50102:  769:        m->msg_iov[m->msg_iovlen].iov_len = len;
        -:  770:
    50102:  771:        c->msgbytes += len;
    50102:  772:        c->iovused++;
    50102:  773:        m->msg_iovlen++;
        -:  774:
    50102:  775:        buf = ((char *)buf) + len;
    50102:  776:        len = leftover;
    50102:  777:    } while (leftover > 0);
        -:  778:
        -:  779:    return 0;
        -:  780:}
        -:  781:
        -:  782:
        -:  783:/*
        -:  784: * Constructs a set of UDP headers and attaches them to the outgoing messages.
        -:  785: */
       39:  786:static int build_udp_headers(conn *c) {
        -:  787:    int i;
        -:  788:    unsigned char *hdr;
        -:  789:
       39:  790:    assert(c != NULL);
        -:  791:
       39:  792:    if (c->msgused > c->hdrsize) {
        -:  793:        void *new_hdrbuf;
        3:  794:        if (c->hdrbuf) {
    #####:  795:            new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);
        -:  796:        } else {
        3:  797:            new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);
        -:  798:        }
        -:  799:
        3:  800:        if (! new_hdrbuf) {
    #####:  801:            STATS_LOCK();
    #####:  802:            stats.malloc_fails++;
    #####:  803:            STATS_UNLOCK();
    #####:  804:            return -1;
        -:  805:        }
        3:  806:        c->hdrbuf = (unsigned char *)new_hdrbuf;
        3:  807:        c->hdrsize = c->msgused * 2;
        -:  808:    }
        -:  809:
       39:  810:    hdr = c->hdrbuf;
       78:  811:    for (i = 0; i < c->msgused; i++) {
       39:  812:        c->msglist[i].msg_iov[0].iov_base = (void*)hdr;
       39:  813:        c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;
       39:  814:        *hdr++ = c->request_id / 256;
       39:  815:        *hdr++ = c->request_id % 256;
       39:  816:        *hdr++ = i / 256;
       39:  817:        *hdr++ = i % 256;
       39:  818:        *hdr++ = c->msgused / 256;
       39:  819:        *hdr++ = c->msgused % 256;
       39:  820:        *hdr++ = 0;
       39:  821:        *hdr++ = 0;
       39:  822:        assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);
        -:  823:    }
        -:  824:
        -:  825:    return 0;
        -:  826:}
        -:  827:
        -:  828:
    35600:  829:static void out_string(conn *c, const char *str) {
        -:  830:    size_t len;
        -:  831:
    35600:  832:    assert(c != NULL);
        -:  833:
    35600:  834:    if (c->noreply) {
    32516:  835:        if (settings.verbose > 1)
    #####:  836:            fprintf(stderr, ">%d NOREPLY %s\n", c->sfd, str);
    32516:  837:        c->noreply = false;
    32516:  838:        conn_set_state(c, conn_new_cmd);
    32516:  839:        return;
        -:  840:    }
        -:  841:
     3084:  842:    if (settings.verbose > 1)
    #####:  843:        fprintf(stderr, ">%d %s\n", c->sfd, str);
        -:  844:
        -:  845:    /* Nuke a partial output... */
     3084:  846:    c->msgcurr = 0;
     3084:  847:    c->msgused = 0;
     3084:  848:    c->iovused = 0;
     3084:  849:    add_msghdr(c);
        -:  850:
     3084:  851:    len = strlen(str);
     3084:  852:    if ((len + 2) > c->wsize) {
        -:  853:        /* ought to be always enough. just fail for simplicity */
    #####:  854:        str = "SERVER_ERROR output line too long";
    #####:  855:        len = strlen(str);
        -:  856:    }
        -:  857:
     3084:  858:    memcpy(c->wbuf, str, len);
     3084:  859:    memcpy(c->wbuf + len, "\r\n", 2);
     3084:  860:    c->wbytes = len + 2;
     3084:  861:    c->wcurr = c->wbuf;
        -:  862:
     3084:  863:    conn_set_state(c, conn_write);
     3084:  864:    c->write_and_go = conn_new_cmd;
     3084:  865:    return;
        -:  866:}
        -:  867:
        -:  868:/*
        -:  869: * Outputs a protocol-specific "out of memory" error. For ASCII clients,
        -:  870: * this is equivalent to out_string().
        -:  871: */
       16:  872:static void out_of_memory(conn *c, char *ascii_error) {
        -:  873:    const static char error_prefix[] = "SERVER_ERROR ";
        -:  874:    const static int error_prefix_len = sizeof(error_prefix) - 1;
        -:  875:
       16:  876:    if (c->protocol == binary_prot) {
        -:  877:        /* Strip off the generic error prefix; it's irrelevant in binary */
    #####:  878:        if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {
    #####:  879:            ascii_error += error_prefix_len;
        -:  880:        }
    #####:  881:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);
        -:  882:    } else {
       16:  883:        out_string(c, ascii_error);
        -:  884:    }
       16:  885:}
        -:  886:
        -:  887:/*
        -:  888: * we get here after reading the value in set/add/replace commands. The command
        -:  889: * has been stored in c->cmd, and the item is ready in c->item.
        -:  890: */
    32748:  891:static void complete_nread_ascii(conn *c) {
    32748:  892:    assert(c != NULL);
        -:  893:
    32748:  894:    item *it = c->item;
    32748:  895:    int comm = c->cmd;
        -:  896:    enum store_item_type ret;
        -:  897:
    32748:  898:    pthread_mutex_lock(&c->thread->stats.mutex);
    32748:  899:    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    32748:  900:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -:  901:
    32748:  902:    if (strncmp(ITEM_data(it) + it->nbytes - 2, "\r\n", 2) != 0) {
    #####:  903:        out_string(c, "CLIENT_ERROR bad data chunk");
        -:  904:    } else {
    32748:  905:      ret = store_item(it, comm, c);
        -:  906:
        -:  907:#ifdef ENABLE_DTRACE
        -:  908:      uint64_t cas = ITEM_get_cas(it);
        -:  909:      switch (c->cmd) {
        -:  910:      case NREAD_ADD:
        -:  911:          MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
        -:  912:                                (ret == 1) ? it->nbytes : -1, cas);
        -:  913:          break;
        -:  914:      case NREAD_REPLACE:
        -:  915:          MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
        -:  916:                                    (ret == 1) ? it->nbytes : -1, cas);
        -:  917:          break;
        -:  918:      case NREAD_APPEND:
        -:  919:          MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
        -:  920:                                   (ret == 1) ? it->nbytes : -1, cas);
        -:  921:          break;
        -:  922:      case NREAD_PREPEND:
        -:  923:          MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
        -:  924:                                    (ret == 1) ? it->nbytes : -1, cas);
        -:  925:          break;
        -:  926:      case NREAD_SET:
        -:  927:          MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
        -:  928:                                (ret == 1) ? it->nbytes : -1, cas);
        -:  929:          break;
        -:  930:      case NREAD_CAS:
        -:  931:          MEMCACHED_COMMAND_CAS(c->sfd, ITEM_key(it), it->nkey, it->nbytes,
        -:  932:                                cas);
        -:  933:          break;
        -:  934:      }
        -:  935:#endif
        -:  936:
    32748:  937:      switch (ret) {
        -:  938:      case STORED:
    32737:  939:          out_string(c, "STORED");
    32737:  940:          break;
        -:  941:      case EXISTS:
        5:  942:          out_string(c, "EXISTS");
        5:  943:          break;
        -:  944:      case NOT_FOUND:
        2:  945:          out_string(c, "NOT_FOUND");
        2:  946:          break;
        -:  947:      case NOT_STORED:
        4:  948:          out_string(c, "NOT_STORED");
        4:  949:          break;
        -:  950:      default:
    #####:  951:          out_string(c, "SERVER_ERROR Unhandled storage type.");
        -:  952:      }
        -:  953:
        -:  954:    }
        -:  955:
    32748:  956:    item_remove(c->item);       /* release the c->item reference */
    32748:  957:    c->item = 0;
    32748:  958:}
        -:  959:
        -:  960:/**
        -:  961: * get a pointer to the start of the request struct for the current command
        -:  962: */
    20366:  963:static void* binary_get_request(conn *c) {
    20366:  964:    char *ret = c->rcurr;
    40732:  965:    ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +
    20366:  966:            c->binary_header.request.extlen);
        -:  967:
    20366:  968:    assert(ret >= c->rbuf);
    20366:  969:    return ret;
        -:  970:}
        -:  971:
        -:  972:/**
        -:  973: * get a pointer to the key in this request
        -:  974: */
        -:  975:static char* binary_get_key(conn *c) {
    21071:  976:    return c->rcurr - (c->binary_header.request.keylen);
        -:  977:}
        -:  978:
     4365:  979:static void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {
        -:  980:    protocol_binary_response_header* header;
        -:  981:
     4365:  982:    assert(c);
        -:  983:
     4365:  984:    c->msgcurr = 0;
     4365:  985:    c->msgused = 0;
     4365:  986:    c->iovused = 0;
     4365:  987:    if (add_msghdr(c) != 0) {
        -:  988:        /* This should never run out of memory because iov and msg lists
        -:  989:         * have minimum sizes big enough to hold an error response.
        -:  990:         */
    #####:  991:        out_of_memory(c, "SERVER_ERROR out of memory adding binary header");
     4365:  992:        return;
        -:  993:    }
        -:  994:
     4365:  995:    header = (protocol_binary_response_header *)c->wbuf;
        -:  996:
     4365:  997:    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;
     4365:  998:    header->response.opcode = c->binary_header.request.opcode;
     4365:  999:    header->response.keylen = (uint16_t)htons(key_len);
        -: 1000:
     4365: 1001:    header->response.extlen = (uint8_t)hdr_len;
     4365: 1002:    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;
     4365: 1003:    header->response.status = (uint16_t)htons(err);
        -: 1004:
     4365: 1005:    header->response.bodylen = htonl(body_len);
     4365: 1006:    header->response.opaque = c->opaque;
     4365: 1007:    header->response.cas = htonll(c->cas);
        -: 1008:
     4365: 1009:    if (settings.verbose > 1) {
        -: 1010:        int ii;
    #####: 1011:        fprintf(stderr, ">%d Writing bin response:", c->sfd);
    #####: 1012:        for (ii = 0; ii < sizeof(header->bytes); ++ii) {
    #####: 1013:            if (ii % 4 == 0) {
    #####: 1014:                fprintf(stderr, "\n>%d  ", c->sfd);
        -: 1015:            }
    #####: 1016:            fprintf(stderr, " 0x%02x", header->bytes[ii]);
        -: 1017:        }
    #####: 1018:        fprintf(stderr, "\n");
        -: 1019:    }
        -: 1020:
     4365: 1021:    add_iov(c, c->wbuf, sizeof(header->response));
        -: 1022:}
        -: 1023:
        -: 1024:/**
        -: 1025: * Writes a binary error response. If errstr is supplied, it is used as the
        -: 1026: * error text; otherwise a generic description of the error status code is
        -: 1027: * included.
        -: 1028: */
     3509: 1029:static void write_bin_error(conn *c, protocol_binary_response_status err,
        -: 1030:                            const char *errstr, int swallow) {
        -: 1031:    size_t len;
        -: 1032:
     3509: 1033:    if (!errstr) {
     3509: 1034:        switch (err) {
        -: 1035:        case PROTOCOL_BINARY_RESPONSE_ENOMEM:
        -: 1036:            errstr = "Out of memory";
        -: 1037:            break;
        -: 1038:        case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:
     3284: 1039:            errstr = "Unknown command";
     3284: 1040:            break;
        -: 1041:        case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:
      144: 1042:            errstr = "Not found";
      144: 1043:            break;
        -: 1044:        case PROTOCOL_BINARY_RESPONSE_EINVAL:
        1: 1045:            errstr = "Invalid arguments";
        1: 1046:            break;
        -: 1047:        case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:
       21: 1048:            errstr = "Data exists for key.";
       21: 1049:            break;
        -: 1050:        case PROTOCOL_BINARY_RESPONSE_E2BIG:
        1: 1051:            errstr = "Too large.";
        1: 1052:            break;
        -: 1053:        case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:
        3: 1054:            errstr = "Non-numeric server-side value for incr or decr";
        3: 1055:            break;
        -: 1056:        case PROTOCOL_BINARY_RESPONSE_NOT_STORED:
       55: 1057:            errstr = "Not stored.";
       55: 1058:            break;
        -: 1059:        case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:
    #####: 1060:            errstr = "Auth failure.";
    #####: 1061:            break;
        -: 1062:        default:
    #####: 1063:            assert(false);
        -: 1064:            errstr = "UNHANDLED ERROR";
        -: 1065:            fprintf(stderr, ">%d UNHANDLED ERROR: %d\n", c->sfd, err);
        -: 1066:        }
        -: 1067:    }
        -: 1068:
     3509: 1069:    if (settings.verbose > 1) {
    #####: 1070:        fprintf(stderr, ">%d Writing an error: %s\n", c->sfd, errstr);
        -: 1071:    }
        -: 1072:
     3509: 1073:    len = strlen(errstr);
     3509: 1074:    add_bin_header(c, err, 0, 0, len);
     3509: 1075:    if (len > 0) {
     3509: 1076:        add_iov(c, errstr, len);
        -: 1077:    }
     3509: 1078:    conn_set_state(c, conn_mwrite);
     3509: 1079:    if(swallow > 0) {
        1: 1080:        c->sbytes = swallow;
        1: 1081:        c->write_and_go = conn_swallow;
        -: 1082:    } else {
     3508: 1083:        c->write_and_go = conn_new_cmd;
        -: 1084:    }
     3509: 1085:}
        -: 1086:
        -: 1087:/* Form and send a response to a command over the binary protocol */
    20232: 1088:static void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {
    20232: 1089:    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||
        -: 1090:        c->cmd == PROTOCOL_BINARY_CMD_GETK) {
      246: 1091:        add_bin_header(c, 0, hlen, keylen, dlen);
      246: 1092:        if(dlen > 0) {
       92: 1093:            add_iov(c, d, dlen);
        -: 1094:        }
      246: 1095:        conn_set_state(c, conn_mwrite);
      246: 1096:        c->write_and_go = conn_new_cmd;
        -: 1097:    } else {
    19986: 1098:        conn_set_state(c, conn_new_cmd);
        -: 1099:    }
    20232: 1100:}
        -: 1101:
      384: 1102:static void complete_incr_bin(conn *c) {
        -: 1103:    item *it;
        -: 1104:    char *key;
        -: 1105:    size_t nkey;
        -: 1106:    /* Weird magic in add_delta forces me to pad here */
        -: 1107:    char tmpbuf[INCR_MAX_STORAGE_LEN];
      128: 1108:    uint64_t cas = 0;
        -: 1109:
      128: 1110:    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;
      128: 1111:    protocol_binary_request_incr* req = binary_get_request(c);
        -: 1112:
      128: 1113:    assert(c != NULL);
      128: 1114:    assert(c->wsize >= sizeof(*rsp));
        -: 1115:
        -: 1116:    /* fix byteorder in the request */
      128: 1117:    req->message.body.delta = ntohll(req->message.body.delta);
      128: 1118:    req->message.body.initial = ntohll(req->message.body.initial);
      256: 1119:    req->message.body.expiration = ntohl(req->message.body.expiration);
      384: 1120:    key = binary_get_key(c);
      128: 1121:    nkey = c->binary_header.request.keylen;
        -: 1122:
      128: 1123:    if (settings.verbose > 1) {
        -: 1124:        int i;
    #####: 1125:        fprintf(stderr, "incr ");
        -: 1126:
    #####: 1127:        for (i = 0; i < nkey; i++) {
    #####: 1128:            fprintf(stderr, "%c", key[i]);
        -: 1129:        }
    #####: 1130:        fprintf(stderr, " %lld, %llu, %d\n",
    #####: 1131:                (long long)req->message.body.delta,
    #####: 1132:                (long long)req->message.body.initial,
        -: 1133:                req->message.body.expiration);
        -: 1134:    }
        -: 1135:
      128: 1136:    if (c->binary_header.request.cas != 0) {
    #####: 1137:        cas = c->binary_header.request.cas;
        -: 1138:    }
      128: 1139:    switch(add_delta(c, key, nkey, c->cmd == PROTOCOL_BINARY_CMD_INCREMENT,
      128: 1140:                     req->message.body.delta, tmpbuf,
        -: 1141:                     &cas)) {
        -: 1142:    case OK:
       56: 1143:        rsp->message.body.value = htonll(strtoull(tmpbuf, NULL, 10));
       56: 1144:        if (cas) {
       56: 1145:            c->cas = cas;
        -: 1146:        }
       56: 1147:        write_bin_response(c, &rsp->message.body, 0, 0,
        -: 1148:                           sizeof(rsp->message.body.value));
       56: 1149:        break;
        -: 1150:    case NON_NUMERIC:
        3: 1151:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, NULL, 0);
        3: 1152:        break;
        -: 1153:    case EOM:
    #####: 1154:        out_of_memory(c, "SERVER_ERROR Out of memory incrementing value");
    #####: 1155:        break;
        -: 1156:    case DELTA_ITEM_NOT_FOUND:
       69: 1157:        if (req->message.body.expiration != 0xffffffff) {
        -: 1158:            /* Save some room for the response */
       69: 1159:            rsp->message.body.value = htonll(req->message.body.initial);
        -: 1160:
        -: 1161:            snprintf(tmpbuf, INCR_MAX_STORAGE_LEN, "%llu",
       69: 1162:                (unsigned long long)req->message.body.initial);
       69: 1163:            int res = strlen(tmpbuf);
      138: 1164:            it = item_alloc(key, nkey, 0, realtime(req->message.body.expiration),
        -: 1165:                            res + 2);
        -: 1166:
       69: 1167:            if (it != NULL) {
       69: 1168:                memcpy(ITEM_data(it), tmpbuf, res);
       69: 1169:                memcpy(ITEM_data(it) + res, "\r\n", 2);
        -: 1170:
       69: 1171:                if (store_item(it, NREAD_ADD, c)) {
       69: 1172:                    c->cas = ITEM_get_cas(it);
       69: 1173:                    write_bin_response(c, &rsp->message.body, 0, 0, sizeof(rsp->message.body.value));
        -: 1174:                } else {
    #####: 1175:                    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED,
        -: 1176:                                    NULL, 0);
        -: 1177:                }
       69: 1178:                item_remove(it);         /* release our reference */
        -: 1179:            } else {
    #####: 1180:                out_of_memory(c,
        -: 1181:                        "SERVER_ERROR Out of memory allocating new item");
        -: 1182:            }
        -: 1183:        } else {
    #####: 1184:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1185:            if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {
    #####: 1186:                c->thread->stats.incr_misses++;
        -: 1187:            } else {
    #####: 1188:                c->thread->stats.decr_misses++;
        -: 1189:            }
    #####: 1190:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1191:
    #####: 1192:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        -: 1193:        }
        -: 1194:        break;
        -: 1195:    case DELTA_ITEM_CAS_MISMATCH:
    #####: 1196:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
    #####: 1197:        break;
        -: 1198:    }
      128: 1199:}
        -: 1200:
    20128: 1201:static void complete_update_bin(conn *c) {
    20128: 1202:    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;
    20128: 1203:    enum store_item_type ret = NOT_STORED;
    20128: 1204:    assert(c != NULL);
        -: 1205:
    20128: 1206:    item *it = c->item;
        -: 1207:
    20128: 1208:    pthread_mutex_lock(&c->thread->stats.mutex);
    20128: 1209:    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    20128: 1210:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1211:
        -: 1212:    /* We don't actually receive the trailing two characters in the bin
        -: 1213:     * protocol, so we're going to just set them here */
    20128: 1214:    *(ITEM_data(it) + it->nbytes - 2) = '\r';
    20128: 1215:    *(ITEM_data(it) + it->nbytes - 1) = '\n';
        -: 1216:
    20128: 1217:    ret = store_item(it, c->cmd, c);
        -: 1218:
        -: 1219:#ifdef ENABLE_DTRACE
        -: 1220:    uint64_t cas = ITEM_get_cas(it);
        -: 1221:    switch (c->cmd) {
        -: 1222:    case NREAD_ADD:
        -: 1223:        MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
        -: 1224:                              (ret == STORED) ? it->nbytes : -1, cas);
        -: 1225:        break;
        -: 1226:    case NREAD_REPLACE:
        -: 1227:        MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
        -: 1228:                                  (ret == STORED) ? it->nbytes : -1, cas);
        -: 1229:        break;
        -: 1230:    case NREAD_APPEND:
        -: 1231:        MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1232:                                 (ret == STORED) ? it->nbytes : -1, cas);
        -: 1233:        break;
        -: 1234:    case NREAD_PREPEND:
        -: 1235:        MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1236:                                 (ret == STORED) ? it->nbytes : -1, cas);
        -: 1237:        break;
        -: 1238:    case NREAD_SET:
        -: 1239:        MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
        -: 1240:                              (ret == STORED) ? it->nbytes : -1, cas);
        -: 1241:        break;
        -: 1242:    }
        -: 1243:#endif
        -: 1244:
    20128: 1245:    switch (ret) {
        -: 1246:    case STORED:
        -: 1247:        /* Stored */
    20018: 1248:        write_bin_response(c, NULL, 0, 0, 0);
    20018: 1249:        break;
        -: 1250:    case EXISTS:
        2: 1251:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
        2: 1252:        break;
        -: 1253:    case NOT_FOUND:
        1: 1254:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        1: 1255:        break;
        -: 1256:    case NOT_STORED:
      107: 1257:        if (c->cmd == NREAD_ADD) {
        -: 1258:            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;
       88: 1259:        } else if(c->cmd == NREAD_REPLACE) {
        -: 1260:            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;
        -: 1261:        } else {
       55: 1262:            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;
        -: 1263:        }
      107: 1264:        write_bin_error(c, eno, NULL, 0);
        -: 1265:    }
        -: 1266:
    20128: 1267:    item_remove(c->item);       /* release the c->item reference */
    20128: 1268:    c->item = 0;
    20128: 1269:}
        -: 1270:
     2262: 1271:static void process_bin_get_or_touch(conn *c) {
        -: 1272:    item *it;
        -: 1273:
      754: 1274:    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;
     2262: 1275:    char* key = binary_get_key(c);
      754: 1276:    size_t nkey = c->binary_header.request.keylen;
     1508: 1277:    int should_touch = (c->cmd == PROTOCOL_BINARY_CMD_TOUCH ||
      754: 1278:                        c->cmd == PROTOCOL_BINARY_CMD_GAT ||
        -: 1279:                        c->cmd == PROTOCOL_BINARY_CMD_GATK);
      754: 1280:    int should_return_key = (c->cmd == PROTOCOL_BINARY_CMD_GETK ||
        -: 1281:                             c->cmd == PROTOCOL_BINARY_CMD_GATK);
      754: 1282:    int should_return_value = (c->cmd != PROTOCOL_BINARY_CMD_TOUCH);
        -: 1283:
      754: 1284:    if (settings.verbose > 1) {
    #####: 1285:        fprintf(stderr, "<%d %s ", c->sfd, should_touch ? "TOUCH" : "GET");
    #####: 1286:        fwrite(key, 1, nkey, stderr);
    #####: 1287:        fputc('\n', stderr);
        -: 1288:    }
        -: 1289:
      754: 1290:    if (should_touch) {
       96: 1291:        protocol_binary_request_touch *t = binary_get_request(c);
      192: 1292:        time_t exptime = ntohl(t->message.body.expiration);
        -: 1293:
       96: 1294:        it = item_touch(key, nkey, realtime(exptime));
        -: 1295:    } else {
      658: 1296:        it = item_get(key, nkey);
        -: 1297:    }
        -: 1298:
      754: 1299:    if (it) {
        -: 1300:        /* the length has two unnecessary bytes ("\r\n") */
      591: 1301:        uint16_t keylen = 0;
      591: 1302:        uint32_t bodylen = sizeof(rsp->message.body) + (it->nbytes - 2);
        -: 1303:
      591: 1304:        item_update(it);
      591: 1305:        pthread_mutex_lock(&c->thread->stats.mutex);
      591: 1306:        if (should_touch) {
       27: 1307:            c->thread->stats.touch_cmds++;
       27: 1308:            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        -: 1309:        } else {
      564: 1310:            c->thread->stats.get_cmds++;
      564: 1311:            c->thread->stats.slab_stats[ITEM_clsid(it)].get_hits++;
        -: 1312:        }
      591: 1313:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1314:
        -: 1315:        if (should_touch) {
        -: 1316:            MEMCACHED_COMMAND_TOUCH(c->sfd, ITEM_key(it), it->nkey,
        -: 1317:                                    it->nbytes, ITEM_get_cas(it));
        -: 1318:        } else {
        -: 1319:            MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
        -: 1320:                                  it->nbytes, ITEM_get_cas(it));
        -: 1321:        }
        -: 1322:
      591: 1323:        if (c->cmd == PROTOCOL_BINARY_CMD_TOUCH) {
        3: 1324:            bodylen -= it->nbytes - 2;
      588: 1325:        } else if (should_return_key) {
       26: 1326:            bodylen += nkey;
       26: 1327:            keylen = nkey;
        -: 1328:        }
        -: 1329:
      591: 1330:        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);
      591: 1331:        rsp->message.header.response.cas = htonll(ITEM_get_cas(it));
        -: 1332:
        -: 1333:        // add the flags
     1182: 1334:        rsp->message.body.flags = htonl(strtoul(ITEM_suffix(it), NULL, 10));
      591: 1335:        add_iov(c, &rsp->message.body, sizeof(rsp->message.body));
        -: 1336:
      591: 1337:        if (should_return_key) {
       26: 1338:            add_iov(c, ITEM_key(it), nkey);
        -: 1339:        }
        -: 1340:
      591: 1341:        if (should_return_value) {
        -: 1342:            /* Add the data minus the CRLF */
      588: 1343:            add_iov(c, ITEM_data(it), it->nbytes - 2);
        -: 1344:        }
        -: 1345:
      591: 1346:        conn_set_state(c, conn_mwrite);
      591: 1347:        c->write_and_go = conn_new_cmd;
        -: 1348:        /* Remember this command so we can garbage collect it later */
      591: 1349:        c->item = it;
        -: 1350:    } else {
      163: 1351:        pthread_mutex_lock(&c->thread->stats.mutex);
      163: 1352:        if (should_touch) {
       69: 1353:            c->thread->stats.touch_cmds++;
       69: 1354:            c->thread->stats.touch_misses++;
        -: 1355:        } else {
       94: 1356:            c->thread->stats.get_cmds++;
       94: 1357:            c->thread->stats.get_misses++;
        -: 1358:        }
      163: 1359:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1360:
        -: 1361:        if (should_touch) {
        -: 1362:            MEMCACHED_COMMAND_TOUCH(c->sfd, key, nkey, -1, 0);
        -: 1363:        } else {
        -: 1364:            MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
        -: 1365:        }
        -: 1366:
      163: 1367:        if (c->noreply) {
       68: 1368:            conn_set_state(c, conn_new_cmd);
        -: 1369:        } else {
       95: 1370:            if (should_return_key) {
       19: 1371:                char *ofs = c->wbuf + sizeof(protocol_binary_response_header);
       19: 1372:                add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
        -: 1373:                        0, nkey, nkey);
        -: 1374:                memcpy(ofs, key, nkey);
       19: 1375:                add_iov(c, ofs, nkey);
       19: 1376:                conn_set_state(c, conn_mwrite);
       19: 1377:                c->write_and_go = conn_new_cmd;
        -: 1378:            } else {
       76: 1379:                write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
        -: 1380:                                NULL, 0);
        -: 1381:            }
        -: 1382:        }
        -: 1383:    }
        -: 1384:
      754: 1385:    if (settings.detail_enabled) {
      554: 1386:        stats_prefix_record_get(key, nkey, NULL != it);
        -: 1387:    }
      754: 1388:}
        -: 1389:
      904: 1390:static void append_bin_stats(const char *key, const uint16_t klen,
        -: 1391:                             const char *val, const uint32_t vlen,
        -: 1392:                             conn *c) {
      904: 1393:    char *buf = c->stats.buffer + c->stats.offset;
      904: 1394:    uint32_t bodylen = klen + vlen;
     3616: 1395:    protocol_binary_response_header header = {
        -: 1396:        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,
        -: 1397:        .response.opcode = PROTOCOL_BINARY_CMD_STAT,
      904: 1398:        .response.keylen = (uint16_t)htons(klen),
        -: 1399:        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,
        -: 1400:        .response.bodylen = htonl(bodylen),
      904: 1401:        .response.opaque = c->opaque
        -: 1402:    };
        -: 1403:
        -: 1404:    memcpy(buf, header.bytes, sizeof(header.response));
      904: 1405:    buf += sizeof(header.response);
        -: 1406:
      904: 1407:    if (klen > 0) {
      885: 1408:        memcpy(buf, key, klen);
      885: 1409:        buf += klen;
        -: 1410:
      885: 1411:        if (vlen > 0) {
      885: 1412:            memcpy(buf, val, vlen);
        -: 1413:        }
        -: 1414:    }
        -: 1415:
      904: 1416:    c->stats.offset += sizeof(header.response) + bodylen;
      904: 1417:}
        -: 1418:
   208075: 1419:static void append_ascii_stats(const char *key, const uint16_t klen,
        -: 1420:                               const char *val, const uint32_t vlen,
        -: 1421:                               conn *c) {
   208075: 1422:    char *pos = c->stats.buffer + c->stats.offset;
   208075: 1423:    uint32_t nbytes = 0;
   208075: 1424:    int remaining = c->stats.size - c->stats.offset;
   208075: 1425:    int room = remaining - 1;
        -: 1426:
   208075: 1427:    if (klen == 0 && vlen == 0) {
     7726: 1428:        nbytes = snprintf(pos, room, "END\r\n");
   204212: 1429:    } else if (vlen == 0) {
    #####: 1430:        nbytes = snprintf(pos, room, "STAT %s\r\n", key);
        -: 1431:    } else {
   408424: 1432:        nbytes = snprintf(pos, room, "STAT %s %s\r\n", key, val);
        -: 1433:    }
        -: 1434:
   208075: 1435:    c->stats.offset += nbytes;
   208075: 1436:}
        -: 1437:
   208979: 1438:static bool grow_stats_buf(conn *c, size_t needed) {
   208979: 1439:    size_t nsize = c->stats.size;
   208979: 1440:    size_t available = nsize - c->stats.offset;
   208979: 1441:    bool rv = true;
        -: 1442:
        -: 1443:    /* Special case: No buffer -- need to allocate fresh */
   208979: 1444:    if (c->stats.buffer == NULL) {
     3883: 1445:        nsize = 1024;
     3883: 1446:        available = c->stats.size = c->stats.offset = 0;
        -: 1447:    }
        -: 1448:
   212876: 1449:    while (needed > available) {
     3897: 1450:        assert(nsize > 0);
     3897: 1451:        nsize = nsize << 1;
     3897: 1452:        available = nsize - c->stats.offset;
        -: 1453:    }
        -: 1454:
   208979: 1455:    if (nsize != c->stats.size) {
     3897: 1456:        char *ptr = realloc(c->stats.buffer, nsize);
     3897: 1457:        if (ptr) {
     3897: 1458:            c->stats.buffer = ptr;
     3897: 1459:            c->stats.size = nsize;
        -: 1460:        } else {
    #####: 1461:            STATS_LOCK();
    #####: 1462:            stats.malloc_fails++;
    #####: 1463:            STATS_UNLOCK();
    #####: 1464:            rv = false;
        -: 1465:        }
        -: 1466:    }
        -: 1467:
   208979: 1468:    return rv;
        -: 1469:}
        -: 1470:
   208979: 1471:static void append_stats(const char *key, const uint16_t klen,
        -: 1472:                  const char *val, const uint32_t vlen,
        -: 1473:                  const void *cookie)
        -: 1474:{
        -: 1475:    /* value without a key is invalid */
   208979: 1476:    if (klen == 0 && vlen > 0) {
        -: 1477:        return ;
        -: 1478:    }
        -: 1479:
   208979: 1480:    conn *c = (conn*)cookie;
        -: 1481:
   208979: 1482:    if (c->protocol == binary_prot) {
      904: 1483:        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);
      904: 1484:        if (!grow_stats_buf(c, needed)) {
        -: 1485:            return ;
        -: 1486:        }
      904: 1487:        append_bin_stats(key, klen, val, vlen, c);
        -: 1488:    } else {
   208075: 1489:        size_t needed = vlen + klen + 10; // 10 == "STAT = \r\n"
   208075: 1490:        if (!grow_stats_buf(c, needed)) {
        -: 1491:            return ;
        -: 1492:        }
   208075: 1493:        append_ascii_stats(key, klen, val, vlen, c);
        -: 1494:    }
        -: 1495:
   208979: 1496:    assert(c->stats.offset <= c->stats.size);
        -: 1497:}
        -: 1498:
       38: 1499:static void process_bin_stat(conn *c) {
       57: 1500:    char *subcommand = binary_get_key(c);
       19: 1501:    size_t nkey = c->binary_header.request.keylen;
        -: 1502:
       19: 1503:    if (settings.verbose > 1) {
        -: 1504:        int ii;
    #####: 1505:        fprintf(stderr, "<%d STATS ", c->sfd);
    #####: 1506:        for (ii = 0; ii < nkey; ++ii) {
    #####: 1507:            fprintf(stderr, "%c", subcommand[ii]);
        -: 1508:        }
    #####: 1509:        fprintf(stderr, "\n");
        -: 1510:    }
        -: 1511:
       19: 1512:    if (nkey == 0) {
        -: 1513:        /* request all statistics */
       16: 1514:        server_stats(&append_stats, c);
       16: 1515:        (void)get_stats(NULL, 0, &append_stats, c);
        3: 1516:    } else if (strncmp(subcommand, "reset", 5) == 0) {
    #####: 1517:        stats_reset();
        3: 1518:    } else if (strncmp(subcommand, "settings", 8) == 0) {
        1: 1519:        process_stat_settings(&append_stats, c);
        2: 1520:    } else if (strncmp(subcommand, "detail", 6) == 0) {
        2: 1521:        char *subcmd_pos = subcommand + 6;
        2: 1522:        if (strncmp(subcmd_pos, " dump", 5) == 0) {
        -: 1523:            int len;
        1: 1524:            char *dump_buf = stats_prefix_dump(&len);
        1: 1525:            if (dump_buf == NULL || len <= 0) {
    #####: 1526:                out_of_memory(c, "SERVER_ERROR Out of memory generating stats");
    #####: 1527:                return ;
        -: 1528:            } else {
        1: 1529:                append_stats("detailed", strlen("detailed"), dump_buf, len, c);
        1: 1530:                free(dump_buf);
        -: 1531:            }
        1: 1532:        } else if (strncmp(subcmd_pos, " on", 3) == 0) {
        1: 1533:            settings.detail_enabled = 1;
    #####: 1534:        } else if (strncmp(subcmd_pos, " off", 4) == 0) {
    #####: 1535:            settings.detail_enabled = 0;
        -: 1536:        } else {
    #####: 1537:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
    #####: 1538:            return;
        -: 1539:        }
        -: 1540:    } else {
    #####: 1541:        if (get_stats(subcommand, nkey, &append_stats, c)) {
    #####: 1542:            if (c->stats.buffer == NULL) {
    #####: 1543:                out_of_memory(c, "SERVER_ERROR Out of memory generating stats");
        -: 1544:            } else {
    #####: 1545:                write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 1546:                c->stats.buffer = NULL;
        -: 1547:            }
        -: 1548:        } else {
    #####: 1549:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        -: 1550:        }
        -: 1551:
        -: 1552:        return;
        -: 1553:    }
        -: 1554:
        -: 1555:    /* Append termination package and start the transfer */
       19: 1556:    append_stats(NULL, 0, NULL, 0, c);
       19: 1557:    if (c->stats.buffer == NULL) {
    #####: 1558:        out_of_memory(c, "SERVER_ERROR Out of memory preparing to send stats");
        -: 1559:    } else {
       19: 1560:        write_and_free(c, c->stats.buffer, c->stats.offset);
       19: 1561:        c->stats.buffer = NULL;
        -: 1562:    }
        -: 1563:}
        -: 1564:
    21108: 1565:static void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {
    21108: 1566:    assert(c);
    21108: 1567:    c->substate = next_substate;
    21108: 1568:    c->rlbytes = c->keylen + extra;
        -: 1569:
        -: 1570:    /* Ok... do we have room for the extras and the key in the input buffer? */
    21108: 1571:    ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;
    21108: 1572:    if (c->rlbytes > c->rsize - offset) {
        2: 1573:        size_t nsize = c->rsize;
        2: 1574:        size_t size = c->rlbytes + sizeof(protocol_binary_request_header);
        -: 1575:
        4: 1576:        while (size > nsize) {
    #####: 1577:            nsize *= 2;
        -: 1578:        }
        -: 1579:
        2: 1580:        if (nsize != c->rsize) {
    #####: 1581:            if (settings.verbose > 1) {
    #####: 1582:                fprintf(stderr, "%d: Need to grow buffer from %lu to %lu\n",
        -: 1583:                        c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);
        -: 1584:            }
    #####: 1585:            char *newm = realloc(c->rbuf, nsize);
    #####: 1586:            if (newm == NULL) {
    #####: 1587:                STATS_LOCK();
    #####: 1588:                stats.malloc_fails++;
    #####: 1589:                STATS_UNLOCK();
    #####: 1590:                if (settings.verbose) {
    #####: 1591:                    fprintf(stderr, "%d: Failed to grow buffer.. closing connection\n",
        -: 1592:                            c->sfd);
        -: 1593:                }
    #####: 1594:                conn_set_state(c, conn_closing);
    21108: 1595:                return;
        -: 1596:            }
        -: 1597:
    #####: 1598:            c->rbuf= newm;
        -: 1599:            /* rcurr should point to the same offset in the packet */
    #####: 1600:            c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);
    #####: 1601:            c->rsize = nsize;
        -: 1602:        }
        2: 1603:        if (c->rbuf != c->rcurr) {
        2: 1604:            memmove(c->rbuf, c->rcurr, c->rbytes);
        2: 1605:            c->rcurr = c->rbuf;
        2: 1606:            if (settings.verbose > 1) {
    #####: 1607:                fprintf(stderr, "%d: Repack input buffer\n", c->sfd);
        -: 1608:            }
        -: 1609:        }
        -: 1610:    }
        -: 1611:
        -: 1612:    /* preserve the header in the buffer.. */
    21108: 1613:    c->ritem = c->rcurr + sizeof(protocol_binary_request_header);
    21108: 1614:    conn_set_state(c, conn_nread);
        -: 1615:}
        -: 1616:
        -: 1617:/* Just write an error message and disconnect the client */
        1: 1618:static void handle_binary_protocol_error(conn *c) {
        1: 1619:    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, 0);
        1: 1620:    if (settings.verbose) {
    #####: 1621:        fprintf(stderr, "Protocol error (opcode %02x), close connection %d\n",
    #####: 1622:                c->binary_header.request.opcode, c->sfd);
        -: 1623:    }
        1: 1624:    c->write_and_go = conn_closing;
        1: 1625:}
        -: 1626:
    #####: 1627:static void init_sasl_conn(conn *c) {
    #####: 1628:    assert(c);
        -: 1629:    /* should something else be returned? */
    #####: 1630:    if (!settings.sasl)
    #####: 1631:        return;
        -: 1632:
    #####: 1633:    c->authenticated = false;
        -: 1634:
    #####: 1635:    if (!c->sasl_conn) {
    #####: 1636:        int result=sasl_server_new("memcached",
        -: 1637:                                   NULL,
        -: 1638:                                   my_sasl_hostname[0] ? my_sasl_hostname : NULL,
        -: 1639:                                   NULL, NULL,
        -: 1640:                                   NULL, 0, &c->sasl_conn);
        -: 1641:        if (result != SASL_OK) {
    #####: 1642:            if (settings.verbose) {
    #####: 1643:                fprintf(stderr, "Failed to initialize SASL conn.\n");
        -: 1644:            }
    #####: 1645:            c->sasl_conn = NULL;
        -: 1646:        }
        -: 1647:    }
        -: 1648:}
        -: 1649:
    #####: 1650:static void bin_list_sasl_mechs(conn *c) {
        -: 1651:    // Guard against a disabled SASL.
    #####: 1652:    if (!settings.sasl) {
    #####: 1653:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
    #####: 1654:                        c->binary_header.request.bodylen
    #####: 1655:                        - c->binary_header.request.keylen);
    #####: 1656:        return;
        -: 1657:    }
        -: 1658:
    #####: 1659:    init_sasl_conn(c);
    #####: 1660:    const char *result_string = NULL;
    #####: 1661:    unsigned int string_length = 0;
    #####: 1662:    int result=sasl_listmech(c->sasl_conn, NULL,
        -: 1663:                             "",   /* What to prepend the string with */
        -: 1664:                             " ",  /* What to separate mechanisms with */
        -: 1665:                             "",   /* What to append to the string */
        -: 1666:                             &result_string, &string_length,
        -: 1667:                             NULL);
        -: 1668:    if (result != SASL_OK) {
        -: 1669:        /* Perhaps there's a better error for this... */
    #####: 1670:        if (settings.verbose) {
    #####: 1671:            fprintf(stderr, "Failed to list SASL mechanisms.\n");
        -: 1672:        }
    #####: 1673:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 1674:        return;
        -: 1675:    }
        -: 1676:    write_bin_response(c, (char*)result_string, 0, 0, string_length);
        -: 1677:}
        -: 1678:
    #####: 1679:static void process_bin_sasl_auth(conn *c) {
        -: 1680:    // Guard for handling disabled SASL on the server.
    #####: 1681:    if (!settings.sasl) {
    #####: 1682:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
    #####: 1683:                        c->binary_header.request.bodylen
    #####: 1684:                        - c->binary_header.request.keylen);
    #####: 1685:        return;
        -: 1686:    }
        -: 1687:
    #####: 1688:    assert(c->binary_header.request.extlen == 0);
        -: 1689:
    #####: 1690:    int nkey = c->binary_header.request.keylen;
    #####: 1691:    int vlen = c->binary_header.request.bodylen - nkey;
        -: 1692:
    #####: 1693:    if (nkey > MAX_SASL_MECH_LEN) {
    #####: 1694:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 1695:        c->write_and_go = conn_swallow;
    #####: 1696:        return;
        -: 1697:    }
        -: 1698:
    #####: 1699:    char *key = binary_get_key(c);
    #####: 1700:    assert(key);
        -: 1701:
    #####: 1702:    item *it = item_alloc(key, nkey, 0, 0, vlen);
        -: 1703:
    #####: 1704:    if (it == 0) {
    #####: 1705:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, NULL, vlen);
    #####: 1706:        c->write_and_go = conn_swallow;
    #####: 1707:        return;
        -: 1708:    }
        -: 1709:
    #####: 1710:    c->item = it;
    #####: 1711:    c->ritem = ITEM_data(it);
    #####: 1712:    c->rlbytes = vlen;
    #####: 1713:    conn_set_state(c, conn_nread);
    #####: 1714:    c->substate = bin_reading_sasl_auth_data;
        -: 1715:}
        -: 1716:
    #####: 1717:static void process_bin_complete_sasl_auth(conn *c) {
    #####: 1718:    assert(settings.sasl);
    #####: 1719:    const char *out = NULL;
    #####: 1720:    unsigned int outlen = 0;
        -: 1721:
    #####: 1722:    assert(c->item);
    #####: 1723:    init_sasl_conn(c);
        -: 1724:
    #####: 1725:    int nkey = c->binary_header.request.keylen;
    #####: 1726:    int vlen = c->binary_header.request.bodylen - nkey;
        -: 1727:
    #####: 1728:    char mech[nkey+1];
    #####: 1729:    memcpy(mech, ITEM_key((item*)c->item), nkey);
    #####: 1730:    mech[nkey] = 0x00;
        -: 1731:
    #####: 1732:    if (settings.verbose)
    #####: 1733:        fprintf(stderr, "mech:  ``%s'' with %d bytes of data\n", mech, vlen);
        -: 1734:
    #####: 1735:    const char *challenge = vlen == 0 ? NULL : ITEM_data((item*) c->item);
        -: 1736:
    #####: 1737:    int result=-1;
        -: 1738:
    #####: 1739:    switch (c->cmd) {
        -: 1740:    case PROTOCOL_BINARY_CMD_SASL_AUTH:
        -: 1741:        result = sasl_server_start(c->sasl_conn, mech,
        -: 1742:                                   challenge, vlen,
        -: 1743:                                   &out, &outlen);
        -: 1744:        break;
        -: 1745:    case PROTOCOL_BINARY_CMD_SASL_STEP:
        -: 1746:        result = sasl_server_step(c->sasl_conn,
        -: 1747:                                  challenge, vlen,
        -: 1748:                                  &out, &outlen);
        -: 1749:        break;
        -: 1750:    default:
    #####: 1751:        assert(false); /* CMD should be one of the above */
        -: 1752:        /* This code is pretty much impossible, but makes the compiler
        -: 1753:           happier */
        -: 1754:        if (settings.verbose) {
        -: 1755:            fprintf(stderr, "Unhandled command %d with challenge %s\n",
        -: 1756:                    c->cmd, challenge);
        -: 1757:        }
        -: 1758:        break;
        -: 1759:    }
        -: 1760:
    #####: 1761:    item_unlink(c->item);
        -: 1762:
    #####: 1763:    if (settings.verbose) {
    #####: 1764:        fprintf(stderr, "sasl result code:  %d\n", result);
        -: 1765:    }
        -: 1766:
        -: 1767:    switch(result) {
        -: 1768:    case SASL_OK:
        -: 1769:        c->authenticated = true;
        -: 1770:        write_bin_response(c, "Authenticated", 0, 0, strlen("Authenticated"));
        -: 1771:        pthread_mutex_lock(&c->thread->stats.mutex);
        -: 1772:        c->thread->stats.auth_cmds++;
        -: 1773:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1774:        break;
        -: 1775:    case SASL_CONTINUE:
        -: 1776:        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);
        -: 1777:        if(outlen > 0) {
        -: 1778:            add_iov(c, out, outlen);
        -: 1779:        }
        -: 1780:        conn_set_state(c, conn_mwrite);
        -: 1781:        c->write_and_go = conn_new_cmd;
        -: 1782:        break;
        -: 1783:    default:
    #####: 1784:        if (settings.verbose)
    #####: 1785:            fprintf(stderr, "Unknown sasl response:  %d\n", result);
    #####: 1786:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 1787:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1788:        c->thread->stats.auth_cmds++;
    #####: 1789:        c->thread->stats.auth_errors++;
    #####: 1790:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1791:    }
    #####: 1792:}
        -: 1793:
    #####: 1794:static bool authenticated(conn *c) {
    #####: 1795:    assert(settings.sasl);
    #####: 1796:    bool rv = false;
        -: 1797:
    #####: 1798:    switch (c->cmd) {
        -: 1799:    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */
        -: 1800:    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */
        -: 1801:    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */
        -: 1802:    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */
        -: 1803:        rv = true;
        -: 1804:        break;
        -: 1805:    default:
    #####: 1806:        rv = c->authenticated;
        -: 1807:    }
        -: 1808:
    #####: 1809:    if (settings.verbose > 1) {
    #####: 1810:        fprintf(stderr, "authenticated() in cmd 0x%02x is %s\n",
        -: 1811:                c->cmd, rv ? "true" : "false");
        -: 1812:    }
        -: 1813:
    #####: 1814:    return rv;
        -: 1815:}
        -: 1816:
    24439: 1817:static void dispatch_bin_command(conn *c) {
    24439: 1818:    int protocol_error = 0;
        -: 1819:
    24439: 1820:    int extlen = c->binary_header.request.extlen;
    24439: 1821:    int keylen = c->binary_header.request.keylen;
    24439: 1822:    uint32_t bodylen = c->binary_header.request.bodylen;
        -: 1823:
    24439: 1824:    if (settings.sasl && !authenticated(c)) {
    #####: 1825:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 1826:        c->write_and_go = conn_closing;
    #####: 1827:        return;
        -: 1828:    }
        -: 1829:
        -: 1830:    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
    24439: 1831:    c->noreply = true;
        -: 1832:
        -: 1833:    /* binprot supports 16bit keys, but internals are still 8bit */
    24439: 1834:    if (keylen > KEY_MAX_LENGTH) {
        1: 1835:        handle_binary_protocol_error(c);
        1: 1836:        return;
        -: 1837:    }
        -: 1838:
    24438: 1839:    switch (c->cmd) {
        -: 1840:    case PROTOCOL_BINARY_CMD_SETQ:
    19882: 1841:        c->cmd = PROTOCOL_BINARY_CMD_SET;
    19882: 1842:        break;
        -: 1843:    case PROTOCOL_BINARY_CMD_ADDQ:
       29: 1844:        c->cmd = PROTOCOL_BINARY_CMD_ADD;
       29: 1845:        break;
        -: 1846:    case PROTOCOL_BINARY_CMD_REPLACEQ:
       29: 1847:        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;
       29: 1848:        break;
        -: 1849:    case PROTOCOL_BINARY_CMD_DELETEQ:
       14: 1850:        c->cmd = PROTOCOL_BINARY_CMD_DELETE;
       14: 1851:        break;
        -: 1852:    case PROTOCOL_BINARY_CMD_INCREMENTQ:
       25: 1853:        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;
       25: 1854:        break;
        -: 1855:    case PROTOCOL_BINARY_CMD_DECREMENTQ:
       23: 1856:        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;
       23: 1857:        break;
        -: 1858:    case PROTOCOL_BINARY_CMD_QUITQ:
        3: 1859:        c->cmd = PROTOCOL_BINARY_CMD_QUIT;
        3: 1860:        break;
        -: 1861:    case PROTOCOL_BINARY_CMD_FLUSHQ:
       16: 1862:        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;
       16: 1863:        break;
        -: 1864:    case PROTOCOL_BINARY_CMD_APPENDQ:
       21: 1865:        c->cmd = PROTOCOL_BINARY_CMD_APPEND;
       21: 1866:        break;
        -: 1867:    case PROTOCOL_BINARY_CMD_PREPENDQ:
       16: 1868:        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;
       16: 1869:        break;
        -: 1870:    case PROTOCOL_BINARY_CMD_GETQ:
       24: 1871:        c->cmd = PROTOCOL_BINARY_CMD_GET;
       24: 1872:        break;
        -: 1873:    case PROTOCOL_BINARY_CMD_GETKQ:
       20: 1874:        c->cmd = PROTOCOL_BINARY_CMD_GETK;
       20: 1875:        break;
        -: 1876:    case PROTOCOL_BINARY_CMD_GATQ:
       19: 1877:        c->cmd = PROTOCOL_BINARY_CMD_GAT;
       19: 1878:        break;
        -: 1879:    case PROTOCOL_BINARY_CMD_GATKQ:
       14: 1880:        c->cmd = PROTOCOL_BINARY_CMD_GATK;
       14: 1881:        break;
        -: 1882:    default:
     4303: 1883:        c->noreply = false;
        -: 1884:    }
        -: 1885:
    24438: 1886:    switch (c->cmd) {
        -: 1887:        case PROTOCOL_BINARY_CMD_VERSION:
       15: 1888:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
       15: 1889:                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));
        -: 1890:            } else {
        -: 1891:                protocol_error = 1;
        -: 1892:            }
        -: 1893:            break;
        -: 1894:        case PROTOCOL_BINARY_CMD_FLUSH:
       37: 1895:            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {
       37: 1896:                bin_read_key(c, bin_read_flush_exptime, extlen);
        -: 1897:            } else {
        -: 1898:                protocol_error = 1;
        -: 1899:            }
        -: 1900:            break;
        -: 1901:        case PROTOCOL_BINARY_CMD_NOOP:
       27: 1902:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
       27: 1903:                write_bin_response(c, NULL, 0, 0, 0);
        -: 1904:            } else {
        -: 1905:                protocol_error = 1;
        -: 1906:            }
        -: 1907:            break;
        -: 1908:        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */
        -: 1909:        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */
        -: 1910:        case PROTOCOL_BINARY_CMD_REPLACE:
    20065: 1911:            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {
    20065: 1912:                bin_read_key(c, bin_reading_set_header, 8);
        -: 1913:            } else {
        -: 1914:                protocol_error = 1;
        -: 1915:            }
        -: 1916:            break;
        -: 1917:        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */
        -: 1918:        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */
        -: 1919:        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */
        -: 1920:        case PROTOCOL_BINARY_CMD_GETK:
      658: 1921:            if (extlen == 0 && bodylen == keylen && keylen > 0) {
      658: 1922:                bin_read_key(c, bin_reading_get_key, 0);
        -: 1923:            } else {
        -: 1924:                protocol_error = 1;
        -: 1925:            }
        -: 1926:            break;
        -: 1927:        case PROTOCOL_BINARY_CMD_DELETE:
       40: 1928:            if (keylen > 0 && extlen == 0 && bodylen == keylen) {
       40: 1929:                bin_read_key(c, bin_reading_del_header, extlen);
        -: 1930:            } else {
        -: 1931:                protocol_error = 1;
        -: 1932:            }
        -: 1933:            break;
        -: 1934:        case PROTOCOL_BINARY_CMD_INCREMENT:
        -: 1935:        case PROTOCOL_BINARY_CMD_DECREMENT:
      128: 1936:            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {
      128: 1937:                bin_read_key(c, bin_reading_incr_header, 20);
        -: 1938:            } else {
        -: 1939:                protocol_error = 1;
        -: 1940:            }
        -: 1941:            break;
        -: 1942:        case PROTOCOL_BINARY_CMD_APPEND:
        -: 1943:        case PROTOCOL_BINARY_CMD_PREPEND:
       65: 1944:            if (keylen > 0 && extlen == 0) {
       65: 1945:                bin_read_key(c, bin_reading_set_header, 0);
        -: 1946:            } else {
        -: 1947:                protocol_error = 1;
        -: 1948:            }
        -: 1949:            break;
        -: 1950:        case PROTOCOL_BINARY_CMD_STAT:
       19: 1951:            if (extlen == 0) {
       19: 1952:                bin_read_key(c, bin_reading_stat, 0);
        -: 1953:            } else {
        -: 1954:                protocol_error = 1;
        -: 1955:            }
        -: 1956:            break;
        -: 1957:        case PROTOCOL_BINARY_CMD_QUIT:
        4: 1958:            if (keylen == 0 && extlen == 0 && bodylen == 0) {
        4: 1959:                write_bin_response(c, NULL, 0, 0, 0);
        4: 1960:                c->write_and_go = conn_closing;
        4: 1961:                if (c->noreply) {
        3: 1962:                    conn_set_state(c, conn_closing);
        -: 1963:                }
        -: 1964:            } else {
        -: 1965:                protocol_error = 1;
        -: 1966:            }
        -: 1967:            break;
        -: 1968:        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:
    #####: 1969:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
    #####: 1970:                bin_list_sasl_mechs(c);
        -: 1971:            } else {
        -: 1972:                protocol_error = 1;
        -: 1973:            }
        -: 1974:            break;
        -: 1975:        case PROTOCOL_BINARY_CMD_SASL_AUTH:
        -: 1976:        case PROTOCOL_BINARY_CMD_SASL_STEP:
    #####: 1977:            if (extlen == 0 && keylen != 0) {
    #####: 1978:                bin_read_key(c, bin_reading_sasl_auth, 0);
        -: 1979:            } else {
        -: 1980:                protocol_error = 1;
        -: 1981:            }
        -: 1982:            break;
        -: 1983:        case PROTOCOL_BINARY_CMD_TOUCH:
        -: 1984:        case PROTOCOL_BINARY_CMD_GAT:
        -: 1985:        case PROTOCOL_BINARY_CMD_GATQ:
        -: 1986:        case PROTOCOL_BINARY_CMD_GATK:
        -: 1987:        case PROTOCOL_BINARY_CMD_GATKQ:
       96: 1988:            if (extlen == 4 && keylen != 0) {
       96: 1989:                bin_read_key(c, bin_reading_touch_key, 4);
        -: 1990:            } else {
        -: 1991:                protocol_error = 1;
        -: 1992:            }
        -: 1993:            break;
        -: 1994:        default:
     3284: 1995:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
        -: 1996:                            bodylen);
        -: 1997:    }
        -: 1998:
    24438: 1999:    if (protocol_error)
    #####: 2000:        handle_binary_protocol_error(c);
        -: 2001:}
        -: 2002:
    60195: 2003:static void process_bin_update(conn *c) {
        -: 2004:    char *key;
        -: 2005:    int nkey;
        -: 2006:    int vlen;
        -: 2007:    item *it;
    20065: 2008:    protocol_binary_request_set* req = binary_get_request(c);
        -: 2009:
    20065: 2010:    assert(c != NULL);
        -: 2011:
    60195: 2012:    key = binary_get_key(c);
    20065: 2013:    nkey = c->binary_header.request.keylen;
        -: 2014:
        -: 2015:    /* fix byteorder in the request */
    40130: 2016:    req->message.body.flags = ntohl(req->message.body.flags);
    40130: 2017:    req->message.body.expiration = ntohl(req->message.body.expiration);
        -: 2018:
    20065: 2019:    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);
        -: 2020:
    20065: 2021:    if (settings.verbose > 1) {
        -: 2022:        int ii;
    #####: 2023:        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {
    #####: 2024:            fprintf(stderr, "<%d ADD ", c->sfd);
    #####: 2025:        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
    #####: 2026:            fprintf(stderr, "<%d SET ", c->sfd);
        -: 2027:        } else {
    #####: 2028:            fprintf(stderr, "<%d REPLACE ", c->sfd);
        -: 2029:        }
    #####: 2030:        for (ii = 0; ii < nkey; ++ii) {
    #####: 2031:            fprintf(stderr, "%c", key[ii]);
        -: 2032:        }
        -: 2033:
    #####: 2034:        fprintf(stderr, " Value len is %d", vlen);
    #####: 2035:        fprintf(stderr, "\n");
        -: 2036:    }
        -: 2037:
    20065: 2038:    if (settings.detail_enabled) {
    19888: 2039:        stats_prefix_record_set(key, nkey);
        -: 2040:    }
        -: 2041:
    60195: 2042:    it = item_alloc(key, nkey, req->message.body.flags,
    20065: 2043:            realtime(req->message.body.expiration), vlen+2);
        -: 2044:
    20065: 2045:    if (it == 0) {
        1: 2046:        if (! item_size_ok(nkey, req->message.body.flags, vlen + 2)) {
        1: 2047:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
        -: 2048:        } else {
    #####: 2049:            out_of_memory(c, "SERVER_ERROR Out of memory allocating item");
        -: 2050:        }
        -: 2051:
        -: 2052:        /* Avoid stale data persisting in cache because we failed alloc.
        -: 2053:         * Unacceptable for SET. Anywhere else too? */
        1: 2054:        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
        1: 2055:            it = item_get(key, nkey);
        1: 2056:            if (it) {
        1: 2057:                item_unlink(it);
        1: 2058:                item_remove(it);
        -: 2059:            }
        -: 2060:        }
        -: 2061:
        -: 2062:        /* swallow the data line */
        1: 2063:        c->write_and_go = conn_swallow;
    20066: 2064:        return;
        -: 2065:    }
        -: 2066:
    20064: 2067:    ITEM_set_cas(it, c->binary_header.request.cas);
        -: 2068:
    20064: 2069:    switch (c->cmd) {
        -: 2070:        case PROTOCOL_BINARY_CMD_ADD:
       78: 2071:            c->cmd = NREAD_ADD;
       78: 2072:            break;
        -: 2073:        case PROTOCOL_BINARY_CMD_SET:
    19931: 2074:            c->cmd = NREAD_SET;
    19931: 2075:            break;
        -: 2076:        case PROTOCOL_BINARY_CMD_REPLACE:
       55: 2077:            c->cmd = NREAD_REPLACE;
       55: 2078:            break;
        -: 2079:        default:
    #####: 2080:            assert(0);
        -: 2081:    }
        -: 2082:
    20064: 2083:    if (ITEM_get_cas(it) != 0) {
        5: 2084:        c->cmd = NREAD_CAS;
        -: 2085:    }
        -: 2086:
    20064: 2087:    c->item = it;
    20064: 2088:    c->ritem = ITEM_data(it);
    20064: 2089:    c->rlbytes = vlen;
    20064: 2090:    conn_set_state(c, conn_nread);
    20064: 2091:    c->substate = bin_read_set_value;
        -: 2092:}
        -: 2093:
      195: 2094:static void process_bin_append_prepend(conn *c) {
        -: 2095:    char *key;
        -: 2096:    int nkey;
        -: 2097:    int vlen;
        -: 2098:    item *it;
        -: 2099:
       65: 2100:    assert(c != NULL);
        -: 2101:
      195: 2102:    key = binary_get_key(c);
       65: 2103:    nkey = c->binary_header.request.keylen;
       65: 2104:    vlen = c->binary_header.request.bodylen - nkey;
        -: 2105:
       65: 2106:    if (settings.verbose > 1) {
    #####: 2107:        fprintf(stderr, "Value len is %d\n", vlen);
        -: 2108:    }
        -: 2109:
       65: 2110:    if (settings.detail_enabled) {
        4: 2111:        stats_prefix_record_set(key, nkey);
        -: 2112:    }
        -: 2113:
       65: 2114:    it = item_alloc(key, nkey, 0, 0, vlen+2);
        -: 2115:
       65: 2116:    if (it == 0) {
    #####: 2117:        if (! item_size_ok(nkey, 0, vlen + 2)) {
    #####: 2118:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
        -: 2119:        } else {
    #####: 2120:            out_of_memory(c, "SERVER_ERROR Out of memory allocating item");
        -: 2121:        }
        -: 2122:        /* swallow the data line */
    #####: 2123:        c->write_and_go = conn_swallow;
       65: 2124:        return;
        -: 2125:    }
        -: 2126:
       65: 2127:    ITEM_set_cas(it, c->binary_header.request.cas);
        -: 2128:
       65: 2129:    switch (c->cmd) {
        -: 2130:        case PROTOCOL_BINARY_CMD_APPEND:
       37: 2131:            c->cmd = NREAD_APPEND;
       37: 2132:            break;
        -: 2133:        case PROTOCOL_BINARY_CMD_PREPEND:
       28: 2134:            c->cmd = NREAD_PREPEND;
       28: 2135:            break;
        -: 2136:        default:
    #####: 2137:            assert(0);
        -: 2138:    }
        -: 2139:
       65: 2140:    c->item = it;
       65: 2141:    c->ritem = ITEM_data(it);
       65: 2142:    c->rlbytes = vlen;
       65: 2143:    conn_set_state(c, conn_nread);
       65: 2144:    c->substate = bin_read_set_value;
        -: 2145:}
        -: 2146:
       37: 2147:static void process_bin_flush(conn *c) {
       37: 2148:    time_t exptime = 0;
       37: 2149:    protocol_binary_request_flush* req = binary_get_request(c);
       37: 2150:    rel_time_t new_oldest = 0;
        -: 2151:
       37: 2152:    if (!settings.flush_enabled) {
        -: 2153:      // flush_all is not allowed but we log it on stats
    #####: 2154:      write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
       37: 2155:      return;
        -: 2156:    }
        -: 2157:
       37: 2158:    if (c->binary_header.request.extlen == sizeof(req->message.body)) {
        8: 2159:        exptime = ntohl(req->message.body.expiration);
        -: 2160:    }
        -: 2161:
       37: 2162:    if (exptime > 0) {
        2: 2163:        new_oldest = realtime(exptime);
        -: 2164:    } else {
       35: 2165:        new_oldest = current_time;
        -: 2166:    }
       37: 2167:    if (settings.use_cas) {
       37: 2168:        settings.oldest_live = new_oldest - 1;
       37: 2169:        if (settings.oldest_live <= current_time)
       35: 2170:            settings.oldest_cas = get_cas_id();
        -: 2171:    } else {
    #####: 2172:        settings.oldest_live = new_oldest;
        -: 2173:    }
        -: 2174:
       37: 2175:    pthread_mutex_lock(&c->thread->stats.mutex);
       37: 2176:    c->thread->stats.flush_cmds++;
       37: 2177:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2178:
       37: 2179:    write_bin_response(c, NULL, 0, 0, 0);
        -: 2180:}
        -: 2181:
      120: 2182:static void process_bin_delete(conn *c) {
        -: 2183:    item *it;
        -: 2184:
       40: 2185:    protocol_binary_request_delete* req = binary_get_request(c);
        -: 2186:
      120: 2187:    char* key = binary_get_key(c);
       40: 2188:    size_t nkey = c->binary_header.request.keylen;
        -: 2189:
       40: 2190:    assert(c != NULL);
        -: 2191:
       40: 2192:    if (settings.verbose > 1) {
        -: 2193:        int ii;
    #####: 2194:        fprintf(stderr, "Deleting ");
    #####: 2195:        for (ii = 0; ii < nkey; ++ii) {
    #####: 2196:            fprintf(stderr, "%c", key[ii]);
        -: 2197:        }
    #####: 2198:        fprintf(stderr, "\n");
        -: 2199:    }
        -: 2200:
       40: 2201:    if (settings.detail_enabled) {
        2: 2202:        stats_prefix_record_delete(key, nkey);
        -: 2203:    }
        -: 2204:
       40: 2205:    it = item_get(key, nkey);
       40: 2206:    if (it) {
        6: 2207:        uint64_t cas = ntohll(req->message.header.request.cas);
        6: 2208:        if (cas == 0 || cas == ITEM_get_cas(it)) {
        -: 2209:            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
        6: 2210:            pthread_mutex_lock(&c->thread->stats.mutex);
        6: 2211:            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
        6: 2212:            pthread_mutex_unlock(&c->thread->stats.mutex);
        6: 2213:            item_unlink(it);
        6: 2214:            write_bin_response(c, NULL, 0, 0, 0);
        -: 2215:        } else {
    #####: 2216:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
        -: 2217:        }
        6: 2218:        item_remove(it);      /* release our reference */
        -: 2219:    } else {
       34: 2220:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
       34: 2221:        pthread_mutex_lock(&c->thread->stats.mutex);
       34: 2222:        c->thread->stats.delete_misses++;
       34: 2223:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2224:    }
       40: 2225:}
        -: 2226:
    41236: 2227:static void complete_nread_binary(conn *c) {
    41236: 2228:    assert(c != NULL);
    41236: 2229:    assert(c->cmd >= 0);
        -: 2230:
    41236: 2231:    switch(c->substate) {
        -: 2232:    case bin_reading_set_header:
    20130: 2233:        if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||
        -: 2234:                c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {
       65: 2235:            process_bin_append_prepend(c);
        -: 2236:        } else {
    20065: 2237:            process_bin_update(c);
        -: 2238:        }
        -: 2239:        break;
        -: 2240:    case bin_read_set_value:
    20128: 2241:        complete_update_bin(c);
    20128: 2242:        break;
        -: 2243:    case bin_reading_get_key:
        -: 2244:    case bin_reading_touch_key:
      754: 2245:        process_bin_get_or_touch(c);
      754: 2246:        break;
        -: 2247:    case bin_reading_stat:
       19: 2248:        process_bin_stat(c);
       19: 2249:        break;
        -: 2250:    case bin_reading_del_header:
       40: 2251:        process_bin_delete(c);
       40: 2252:        break;
        -: 2253:    case bin_reading_incr_header:
      128: 2254:        complete_incr_bin(c);
      128: 2255:        break;
        -: 2256:    case bin_read_flush_exptime:
       37: 2257:        process_bin_flush(c);
       37: 2258:        break;
        -: 2259:    case bin_reading_sasl_auth:
    #####: 2260:        process_bin_sasl_auth(c);
    #####: 2261:        break;
        -: 2262:    case bin_reading_sasl_auth_data:
    #####: 2263:        process_bin_complete_sasl_auth(c);
    #####: 2264:        break;
        -: 2265:    default:
    #####: 2266:        fprintf(stderr, "Not handling substate %d\n", c->substate);
    #####: 2267:        assert(0);
        -: 2268:    }
    41236: 2269:}
        -: 2270:
    69834: 2271:static void reset_cmd_handler(conn *c) {
    69834: 2272:    c->cmd = -1;
    69834: 2273:    c->substate = bin_no_state;
    69834: 2274:    if(c->item != NULL) {
    #####: 2275:        item_remove(c->item);
    #####: 2276:        c->item = NULL;
        -: 2277:    }
    69834: 2278:    conn_shrink(c);
    69834: 2279:    if (c->rbytes > 0) {
    53780: 2280:        conn_set_state(c, conn_parse_cmd);
        -: 2281:    } else {
    16054: 2282:        conn_set_state(c, conn_waiting);
        -: 2283:    }
    69834: 2284:}
        -: 2285:
    73984: 2286:static void complete_nread(conn *c) {
    73984: 2287:    assert(c != NULL);
    73984: 2288:    assert(c->protocol == ascii_prot
        -: 2289:           || c->protocol == binary_prot);
        -: 2290:
    73984: 2291:    if (c->protocol == ascii_prot) {
    32748: 2292:        complete_nread_ascii(c);
    41236: 2293:    } else if (c->protocol == binary_prot) {
    41236: 2294:        complete_nread_binary(c);
        -: 2295:    }
    73984: 2296:}
        -: 2297:
        -: 2298:/*
        -: 2299: * Stores an item in the cache according to the semantics of one of the set
        -: 2300: * commands. In threaded mode, this is protected by the cache lock.
        -: 2301: *
        -: 2302: * Returns the state of storage.
        -: 2303: */
    52945: 2304:enum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t hv) {
    52945: 2305:    char *key = ITEM_key(it);
    52945: 2306:    item *old_it = do_item_get(key, it->nkey, hv);
    52945: 2307:    enum store_item_type stored = NOT_STORED;
        -: 2308:
    52945: 2309:    item *new_it = NULL;
        -: 2310:    int flags;
        -: 2311:
    52945: 2312:    if (old_it != NULL && comm == NREAD_ADD) {
        -: 2313:        /* add only adds a nonexistent item, but promote to head of LRU */
       22: 2314:        do_item_update(old_it);
    86309: 2315:    } else if (!old_it && (comm == NREAD_REPLACE
    33386: 2316:        || comm == NREAD_APPEND || comm == NREAD_PREPEND))
        -: 2317:    {
        -: 2318:        /* replace only replaces an existing value; don't store */
    52834: 2319:    } else if (comm == NREAD_CAS) {
        -: 2320:        /* validate cas operation */
       17: 2321:        if(old_it == NULL) {
        -: 2322:            // LRU expired
        3: 2323:            stored = NOT_FOUND;
        3: 2324:            pthread_mutex_lock(&c->thread->stats.mutex);
        3: 2325:            c->thread->stats.cas_misses++;
        3: 2326:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2327:        }
       14: 2328:        else if (ITEM_get_cas(it) == ITEM_get_cas(old_it)) {
        -: 2329:            // cas validates
        -: 2330:            // it and old_it may belong to different classes.
        -: 2331:            // I'm updating the stats for the one that's getting pushed out
        7: 2332:            pthread_mutex_lock(&c->thread->stats.mutex);
        7: 2333:            c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;
        7: 2334:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2335:
        7: 2336:            item_replace(old_it, it, hv);
        7: 2337:            stored = STORED;
        -: 2338:        } else {
        7: 2339:            pthread_mutex_lock(&c->thread->stats.mutex);
        7: 2340:            c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_badval++;
        7: 2341:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2342:
        7: 2343:            if(settings.verbose > 1) {
    #####: 2344:                fprintf(stderr, "CAS:  failure: expected %llu, got %llu\n",
    #####: 2345:                        (unsigned long long)ITEM_get_cas(old_it),
    #####: 2346:                        (unsigned long long)ITEM_get_cas(it));
        -: 2347:            }
        -: 2348:            stored = EXISTS;
        -: 2349:        }
        -: 2350:    } else {
        -: 2351:        /*
        -: 2352:         * Append - combine new and old record into single one. Here it's
        -: 2353:         * atomic and thread-safe.
        -: 2354:         */
    52817: 2355:        if (comm == NREAD_APPEND || comm == NREAD_PREPEND) {
        -: 2356:            /*
        -: 2357:             * Validate CAS
        -: 2358:             */
       12: 2359:            if (ITEM_get_cas(it) != 0) {
        -: 2360:                // CAS much be equal
    #####: 2361:                if (ITEM_get_cas(it) != ITEM_get_cas(old_it)) {
    #####: 2362:                    stored = EXISTS;
        -: 2363:                }
        -: 2364:            }
        -: 2365:
       12: 2366:            if (stored == NOT_STORED) {
        -: 2367:                /* we have it and old_it here - alloc memory to hold both */
        -: 2368:                /* flags was already lost - so recover them from ITEM_suffix(it) */
        -: 2369:
       12: 2370:                flags = (int) strtol(ITEM_suffix(old_it), (char **) NULL, 10);
        -: 2371:
       12: 2372:                new_it = do_item_alloc(key, it->nkey, flags, old_it->exptime, it->nbytes + old_it->nbytes - 2 /* CRLF */, hv);
        -: 2373:
       12: 2374:                if (new_it == NULL) {
        -: 2375:                    /* SERVER_ERROR out of memory */
    #####: 2376:                    if (old_it != NULL)
    #####: 2377:                        do_item_remove(old_it);
        -: 2378:
        -: 2379:                    return NOT_STORED;
        -: 2380:                }
        -: 2381:
        -: 2382:                /* copy data from it and old_it to new_it */
        -: 2383:
       12: 2384:                if (comm == NREAD_APPEND) {
        6: 2385:                    memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);
        6: 2386:                    memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(it), it->nbytes);
        -: 2387:                } else {
        -: 2388:                    /* NREAD_PREPEND */
        6: 2389:                    memcpy(ITEM_data(new_it), ITEM_data(it), it->nbytes);
        6: 2390:                    memcpy(ITEM_data(new_it) + it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);
        -: 2391:                }
        -: 2392:
       12: 2393:                it = new_it;
        -: 2394:            }
        -: 2395:        }
        -: 2396:
    52817: 2397:        if (stored == NOT_STORED) {
    52817: 2398:            if (old_it != NULL)
    19523: 2399:                item_replace(old_it, it, hv);
        -: 2400:            else
    33294: 2401:                do_item_link(it, hv);
        -: 2402:
    52817: 2403:            c->cas = ITEM_get_cas(it);
        -: 2404:
    52817: 2405:            stored = STORED;
        -: 2406:        }
        -: 2407:    }
        -: 2408:
    52945: 2409:    if (old_it != NULL)
    19559: 2410:        do_item_remove(old_it);         /* release our reference */
    52945: 2411:    if (new_it != NULL)
       12: 2412:        do_item_remove(new_it);
        -: 2413:
    52945: 2414:    if (stored == STORED) {
    52824: 2415:        c->cas = ITEM_get_cas(it);
        -: 2416:    }
        -: 2417:
    52945: 2418:    return stored;
        -: 2419:}
        -: 2420:
        -: 2421:typedef struct token_s {
        -: 2422:    char *value;
        -: 2423:    size_t length;
        -: 2424:} token_t;
        -: 2425:
        -: 2426:#define COMMAND_TOKEN 0
        -: 2427:#define SUBCOMMAND_TOKEN 1
        -: 2428:#define KEY_TOKEN 1
        -: 2429:
        -: 2430:#define MAX_TOKENS 8
        -: 2431:
        -: 2432:/*
        -: 2433: * Tokenize the command string by replacing whitespace with '\0' and update
        -: 2434: * the token array tokens with pointer to start of each token and length.
        -: 2435: * Returns total number of tokens.  The last valid token is the terminal
        -: 2436: * token (value points to the first unprocessed character of the string and
        -: 2437: * length zero).
        -: 2438: *
        -: 2439: * Usage example:
        -: 2440: *
        -: 2441: *  while(tokenize_command(command, ncommand, tokens, max_tokens) > 0) {
        -: 2442: *      for(int ix = 0; tokens[ix].length != 0; ix++) {
        -: 2443: *          ...
        -: 2444: *      }
        -: 2445: *      ncommand = tokens[ix].value - command;
        -: 2446: *      command  = tokens[ix].value;
        -: 2447: *   }
        -: 2448: */
    45438: 2449:static size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {
        -: 2450:    char *s, *e;
    45438: 2451:    size_t ntokens = 0;
    45438: 2452:    size_t len = strlen(command);
    45438: 2453:    unsigned int i = 0;
        -: 2454:
    45438: 2455:    assert(command != NULL && tokens != NULL && max_tokens > 1);
        -: 2456:
        -: 2457:    s = e = command;
  1213181: 2458:    for (i = 0; i < len; i++) {
  1213301: 2459:        if (*e == ' ') {
   173505: 2460:            if (s != e) {
   173493: 2461:                tokens[ntokens].value = s;
   173493: 2462:                tokens[ntokens].length = e - s;
   173493: 2463:                ntokens++;
   173493: 2464:                *e = '\0';
   173493: 2465:                if (ntokens == max_tokens - 1) {
      120: 2466:                    e++;
      120: 2467:                    s = e; /* so we don't add an extra token */
      120: 2468:                    break;
        -: 2469:                }
        -: 2470:            }
   173385: 2471:            s = e + 1;
        -: 2472:        }
  1213181: 2473:        e++;
        -: 2474:    }
        -: 2475:
    45438: 2476:    if (s != e) {
    45315: 2477:        tokens[ntokens].value = s;
    45315: 2478:        tokens[ntokens].length = e - s;
    45315: 2479:        ntokens++;
        -: 2480:    }
        -: 2481:
        -: 2482:    /*
        -: 2483:     * If we scanned the whole string, the terminal value pointer is null,
        -: 2484:     * otherwise it is the first unprocessed character.
        -: 2485:     */
    45438: 2486:    tokens[ntokens].value =  *e == '\0' ? NULL : e;
    45438: 2487:    tokens[ntokens].length = 0;
    45438: 2488:    ntokens++;
        -: 2489:
    45438: 2490:    return ntokens;
        -: 2491:}
        -: 2492:
        -: 2493:/* set up a connection to write a buffer then free it, used for stats */
     3892: 2494:static void write_and_free(conn *c, char *buf, int bytes) {
     3892: 2495:    if (buf) {
     3892: 2496:        c->write_and_free = buf;
     3892: 2497:        c->wcurr = buf;
     3892: 2498:        c->wbytes = bytes;
     3892: 2499:        conn_set_state(c, conn_write);
     3892: 2500:        c->write_and_go = conn_new_cmd;
        -: 2501:    } else {
    #####: 2502:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 2503:    }
     3892: 2504:}
        -: 2505:
    35567: 2506:static inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)
        -: 2507:{
    35567: 2508:    int noreply_index = ntokens - 2;
        -: 2509:
        -: 2510:    /*
        -: 2511:      NOTE: this function is not the first place where we are going to
        -: 2512:      send the reply.  We could send it instead from process_command()
        -: 2513:      if the request line has wrong number of tokens.  However parsing
        -: 2514:      malformed line for "noreply" option is not reliable anyway, so
        -: 2515:      it can't be helped.
        -: 2516:    */
    35567: 2517:    if (tokens[noreply_index].value
    35567: 2518:        && strcmp(tokens[noreply_index].value, "noreply") == 0) {
    32516: 2519:        c->noreply = true;
        -: 2520:    }
    35567: 2521:    return c->noreply;
        -: 2522:}
        -: 2523:
   203848: 2524:void append_stat(const char *name, ADD_STAT add_stats, conn *c,
        -: 2525:                 const char *fmt, ...) {
        -: 2526:    char val_str[STAT_VAL_LEN];
        -: 2527:    int vlen;
        -: 2528:    va_list ap;
        -: 2529:
   203848: 2530:    assert(name);
   203848: 2531:    assert(add_stats);
   203848: 2532:    assert(c);
   203848: 2533:    assert(fmt);
        -: 2534:
   203848: 2535:    va_start(ap, fmt);
   203848: 2536:    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);
   203848: 2537:    va_end(ap);
        -: 2538:
   203848: 2539:    add_stats(name, strlen(name), val_str, vlen, c);
   203848: 2540:}
        -: 2541:
       10: 2542:inline static void process_stats_detail(conn *c, const char *command) {
       10: 2543:    assert(c != NULL);
        -: 2544:
       10: 2545:    if (strcmp(command, "on") == 0) {
        1: 2546:        settings.detail_enabled = 1;
        1: 2547:        out_string(c, "OK");
        -: 2548:    }
        9: 2549:    else if (strcmp(command, "off") == 0) {
        1: 2550:        settings.detail_enabled = 0;
        1: 2551:        out_string(c, "OK");
        -: 2552:    }
        8: 2553:    else if (strcmp(command, "dump") == 0) {
        -: 2554:        int len;
        8: 2555:        char *stats = stats_prefix_dump(&len);
        8: 2556:        write_and_free(c, stats, len);
        -: 2557:    }
        -: 2558:    else {
    #####: 2559:        out_string(c, "CLIENT_ERROR usage: stats detail on|off|dump");
        -: 2560:    }
       10: 2561:}
        -: 2562:
        -: 2563:/* return server specific stats only */
     3834: 2564:static void server_stats(ADD_STAT add_stats, conn *c) {
     3834: 2565:    pid_t pid = getpid();
     3834: 2566:    rel_time_t now = current_time;
        -: 2567:
        -: 2568:    struct thread_stats thread_stats;
     3834: 2569:    threadlocal_stats_aggregate(&thread_stats);
        -: 2570:    struct slab_stats slab_stats;
     3834: 2571:    slab_stats_aggregate(&thread_stats, &slab_stats);
        -: 2572:
        -: 2573:#ifndef WIN32
        -: 2574:    struct rusage usage;
     3834: 2575:    getrusage(RUSAGE_SELF, &usage);
        -: 2576:#endif /* !WIN32 */
        -: 2577:
     3834: 2578:    STATS_LOCK();
        -: 2579:
     3833: 2580:    APPEND_STAT("pid", "%lu", (long)pid);
     3833: 2581:    APPEND_STAT("uptime", "%u", now - ITEM_UPDATE_INTERVAL);
     3833: 2582:    APPEND_STAT("time", "%ld", now + (long)process_started);
     3833: 2583:    APPEND_STAT("version", "%s", VERSION);
     3833: 2584:    APPEND_STAT("libevent", "%s", event_get_version());
     3833: 2585:    APPEND_STAT("pointer_size", "%d", (int)(8 * sizeof(void *)));
        -: 2586:
        -: 2587:#ifndef WIN32
     3833: 2588:    append_stat("rusage_user", add_stats, c, "%ld.%06ld",
        -: 2589:                (long)usage.ru_utime.tv_sec,
        -: 2590:                (long)usage.ru_utime.tv_usec);
     3833: 2591:    append_stat("rusage_system", add_stats, c, "%ld.%06ld",
        -: 2592:                (long)usage.ru_stime.tv_sec,
        -: 2593:                (long)usage.ru_stime.tv_usec);
        -: 2594:#endif /* !WIN32 */
        -: 2595:
     3833: 2596:    APPEND_STAT("curr_connections", "%u", stats.curr_conns - 1);
     3833: 2597:    APPEND_STAT("total_connections", "%u", stats.total_conns);
     3833: 2598:    if (settings.maxconns_fast) {
    #####: 2599:        APPEND_STAT("rejected_connections", "%llu", (unsigned long long)stats.rejected_conns);
        -: 2600:    }
     3833: 2601:    APPEND_STAT("connection_structures", "%u", stats.conn_structs);
     3833: 2602:    APPEND_STAT("reserved_fds", "%u", stats.reserved_fds);
     3833: 2603:    APPEND_STAT("cmd_get", "%llu", (unsigned long long)thread_stats.get_cmds);
     3833: 2604:    APPEND_STAT("cmd_set", "%llu", (unsigned long long)slab_stats.set_cmds);
     3833: 2605:    APPEND_STAT("cmd_flush", "%llu", (unsigned long long)thread_stats.flush_cmds);
     3833: 2606:    APPEND_STAT("cmd_touch", "%llu", (unsigned long long)thread_stats.touch_cmds);
     3833: 2607:    APPEND_STAT("get_hits", "%llu", (unsigned long long)slab_stats.get_hits);
     3833: 2608:    APPEND_STAT("get_misses", "%llu", (unsigned long long)thread_stats.get_misses);
     3833: 2609:    APPEND_STAT("delete_misses", "%llu", (unsigned long long)thread_stats.delete_misses);
     3833: 2610:    APPEND_STAT("delete_hits", "%llu", (unsigned long long)slab_stats.delete_hits);
     3833: 2611:    APPEND_STAT("incr_misses", "%llu", (unsigned long long)thread_stats.incr_misses);
     3833: 2612:    APPEND_STAT("incr_hits", "%llu", (unsigned long long)slab_stats.incr_hits);
     3833: 2613:    APPEND_STAT("decr_misses", "%llu", (unsigned long long)thread_stats.decr_misses);
     3833: 2614:    APPEND_STAT("decr_hits", "%llu", (unsigned long long)slab_stats.decr_hits);
     3833: 2615:    APPEND_STAT("cas_misses", "%llu", (unsigned long long)thread_stats.cas_misses);
     3833: 2616:    APPEND_STAT("cas_hits", "%llu", (unsigned long long)slab_stats.cas_hits);
     3833: 2617:    APPEND_STAT("cas_badval", "%llu", (unsigned long long)slab_stats.cas_badval);
     3833: 2618:    APPEND_STAT("touch_hits", "%llu", (unsigned long long)slab_stats.touch_hits);
     3833: 2619:    APPEND_STAT("touch_misses", "%llu", (unsigned long long)thread_stats.touch_misses);
     3833: 2620:    APPEND_STAT("auth_cmds", "%llu", (unsigned long long)thread_stats.auth_cmds);
     3833: 2621:    APPEND_STAT("auth_errors", "%llu", (unsigned long long)thread_stats.auth_errors);
     3833: 2622:    APPEND_STAT("bytes_read", "%llu", (unsigned long long)thread_stats.bytes_read);
     3833: 2623:    APPEND_STAT("bytes_written", "%llu", (unsigned long long)thread_stats.bytes_written);
     3833: 2624:    APPEND_STAT("limit_maxbytes", "%llu", (unsigned long long)settings.maxbytes);
     3833: 2625:    APPEND_STAT("accepting_conns", "%u", stats.accepting_conns);
     3833: 2626:    APPEND_STAT("listen_disabled_num", "%llu", (unsigned long long)stats.listen_disabled_num);
     3833: 2627:    APPEND_STAT("time_in_listen_disabled_us", "%llu", stats.time_in_listen_disabled_us);
     3833: 2628:    APPEND_STAT("threads", "%d", settings.num_threads);
     3833: 2629:    APPEND_STAT("conn_yields", "%llu", (unsigned long long)thread_stats.conn_yields);
     3833: 2630:    APPEND_STAT("hash_power_level", "%u", stats.hash_power_level);
     3833: 2631:    APPEND_STAT("hash_bytes", "%llu", (unsigned long long)stats.hash_bytes);
     3833: 2632:    APPEND_STAT("hash_is_expanding", "%u", stats.hash_is_expanding);
     3833: 2633:    if (settings.slab_reassign) {
        6: 2634:        APPEND_STAT("slab_reassign_rescues", "%llu", stats.slab_reassign_rescues);
        6: 2635:        APPEND_STAT("slab_reassign_evictions_nomem", "%llu", stats.slab_reassign_evictions_nomem);
        6: 2636:        APPEND_STAT("slab_reassign_inline_reclaim", "%llu", stats.slab_reassign_inline_reclaim);
        6: 2637:        APPEND_STAT("slab_reassign_busy_items", "%llu", stats.slab_reassign_busy_items);
        6: 2638:        APPEND_STAT("slab_reassign_running", "%u", stats.slab_reassign_running);
        6: 2639:        APPEND_STAT("slabs_moved", "%llu", stats.slabs_moved);
        -: 2640:    }
     3833: 2641:    if (settings.lru_crawler) {
       10: 2642:        APPEND_STAT("lru_crawler_running", "%u", stats.lru_crawler_running);
       10: 2643:        APPEND_STAT("lru_crawler_starts", "%u", stats.lru_crawler_starts);
        -: 2644:    }
     3833: 2645:    if (settings.lru_maintainer_thread) {
        7: 2646:        APPEND_STAT("lru_maintainer_juggles", "%llu", (unsigned long long)stats.lru_maintainer_juggles);
        -: 2647:    }
     3833: 2648:    APPEND_STAT("malloc_fails", "%llu",
        -: 2649:                (unsigned long long)stats.malloc_fails);
     3833: 2650:    STATS_UNLOCK();
     3833: 2651:}
        -: 2652:
       16: 2653:static void process_stat_settings(ADD_STAT add_stats, void *c) {
       16: 2654:    assert(add_stats);
       16: 2655:    APPEND_STAT("maxbytes", "%llu", (unsigned long long)settings.maxbytes);
       16: 2656:    APPEND_STAT("maxconns", "%d", settings.maxconns);
       16: 2657:    APPEND_STAT("tcpport", "%d", settings.port);
       16: 2658:    APPEND_STAT("udpport", "%d", settings.udpport);
       16: 2659:    APPEND_STAT("inter", "%s", settings.inter ? settings.inter : "NULL");
       16: 2660:    APPEND_STAT("verbosity", "%d", settings.verbose);
       16: 2661:    APPEND_STAT("oldest", "%lu", (unsigned long)settings.oldest_live);
       16: 2662:    APPEND_STAT("evictions", "%s", settings.evict_to_free ? "on" : "off");
       16: 2663:    APPEND_STAT("domain_socket", "%s",
        -: 2664:                settings.socketpath ? settings.socketpath : "NULL");
       16: 2665:    APPEND_STAT("umask", "%o", settings.access);
       16: 2666:    APPEND_STAT("growth_factor", "%.2f", settings.factor);
       16: 2667:    APPEND_STAT("chunk_size", "%d", settings.chunk_size);
       16: 2668:    APPEND_STAT("num_threads", "%d", settings.num_threads);
       16: 2669:    APPEND_STAT("num_threads_per_udp", "%d", settings.num_threads_per_udp);
       16: 2670:    APPEND_STAT("stat_key_prefix", "%c", settings.prefix_delimiter);
       16: 2671:    APPEND_STAT("detail_enabled", "%s",
        -: 2672:                settings.detail_enabled ? "yes" : "no");
       16: 2673:    APPEND_STAT("reqs_per_event", "%d", settings.reqs_per_event);
       16: 2674:    APPEND_STAT("cas_enabled", "%s", settings.use_cas ? "yes" : "no");
       16: 2675:    APPEND_STAT("tcp_backlog", "%d", settings.backlog);
       32: 2676:    APPEND_STAT("binding_protocol", "%s",
        -: 2677:                prot_text(settings.binding_protocol));
       16: 2678:    APPEND_STAT("auth_enabled_sasl", "%s", settings.sasl ? "yes" : "no");
       16: 2679:    APPEND_STAT("item_size_max", "%d", settings.item_size_max);
       16: 2680:    APPEND_STAT("maxconns_fast", "%s", settings.maxconns_fast ? "yes" : "no");
       16: 2681:    APPEND_STAT("hashpower_init", "%d", settings.hashpower_init);
       16: 2682:    APPEND_STAT("slab_reassign", "%s", settings.slab_reassign ? "yes" : "no");
       16: 2683:    APPEND_STAT("slab_automove", "%d", settings.slab_automove);
       16: 2684:    APPEND_STAT("lru_crawler", "%s", settings.lru_crawler ? "yes" : "no");
       16: 2685:    APPEND_STAT("lru_crawler_sleep", "%d", settings.lru_crawler_sleep);
       16: 2686:    APPEND_STAT("lru_crawler_tocrawl", "%lu", (unsigned long)settings.lru_crawler_tocrawl);
       16: 2687:    APPEND_STAT("tail_repair_time", "%d", settings.tail_repair_time);
       16: 2688:    APPEND_STAT("flush_enabled", "%s", settings.flush_enabled ? "yes" : "no");
       16: 2689:    APPEND_STAT("hash_algorithm", "%s", settings.hash_algorithm);
       16: 2690:    APPEND_STAT("lru_maintainer_thread", "%s", settings.lru_maintainer_thread ? "yes" : "no");
       16: 2691:    APPEND_STAT("hot_lru_pct", "%d", settings.hot_lru_pct);
       16: 2692:    APPEND_STAT("warm_lru_pct", "%d", settings.warm_lru_pct);
       16: 2693:    APPEND_STAT("expirezero_does_not_evict", "%s", settings.expirezero_does_not_evict ? "yes" : "no");
       16: 2694:}
        -: 2695:
       14: 2696:static void conn_to_str(const conn *c, char *buf) {
        -: 2697:    char addr_text[MAXPATHLEN];
        -: 2698:
       14: 2699:    if (!c) {
        -: 2700:        strcpy(buf, "<null>");
       14: 2701:    } else if (c->state == conn_closed) {
        -: 2702:        strcpy(buf, "<closed>");
        -: 2703:    } else {
       14: 2704:        const char *protoname = "?";
        -: 2705:        struct sockaddr_in6 local_addr;
       14: 2706:        struct sockaddr *addr = (void *)&c->request_addr;
        -: 2707:        int af;
       14: 2708:        unsigned short port = 0;
        -: 2709:
        -: 2710:        /* For listen ports and idle UDP ports, show listen address */
       25: 2711:        if (c->state == conn_listening ||
       19: 2712:                (IS_UDP(c->transport) &&
        -: 2713:                 c->state == conn_read)) {
       11: 2714:            socklen_t local_addr_len = sizeof(local_addr);
        -: 2715:
       11: 2716:            if (getsockname(c->sfd,
        -: 2717:                        (struct sockaddr *)&local_addr,
        -: 2718:                        &local_addr_len) == 0) {
       11: 2719:                addr = (struct sockaddr *)&local_addr;
        -: 2720:            }
        -: 2721:        }
        -: 2722:
       14: 2723:        af = addr->sa_family;
       14: 2724:        addr_text[0] = '\0';
        -: 2725:
       14: 2726:        switch (af) {
        -: 2727:            case AF_INET:
        6: 2728:                (void) inet_ntop(af,
        6: 2729:                        &((struct sockaddr_in *)addr)->sin_addr,
        -: 2730:                        addr_text,
        -: 2731:                        sizeof(addr_text) - 1);
        6: 2732:                port = ntohs(((struct sockaddr_in *)addr)->sin_port);
        6: 2733:                protoname = IS_UDP(c->transport) ? "udp" : "tcp";
        6: 2734:                break;
        -: 2735:
        -: 2736:            case AF_INET6:
        5: 2737:                addr_text[0] = '[';
        5: 2738:                addr_text[1] = '\0';
        5: 2739:                if (inet_ntop(af,
        5: 2740:                        &((struct sockaddr_in6 *)addr)->sin6_addr,
        -: 2741:                        addr_text + 1,
        -: 2742:                        sizeof(addr_text) - 2)) {
        -: 2743:                    strcat(addr_text, "]");
        -: 2744:                }
        5: 2745:                port = ntohs(((struct sockaddr_in6 *)addr)->sin6_port);
        5: 2746:                protoname = IS_UDP(c->transport) ? "udp6" : "tcp6";
        5: 2747:                break;
        -: 2748:
        -: 2749:            case AF_UNIX:
        -: 2750:                strncpy(addr_text,
        1: 2751:                        ((struct sockaddr_un *)addr)->sun_path,
        -: 2752:                        sizeof(addr_text) - 1);
        1: 2753:                addr_text[sizeof(addr_text)-1] = '\0';
        1: 2754:                protoname = "unix";
        1: 2755:                break;
        -: 2756:        }
        -: 2757:
       14: 2758:        if (strlen(addr_text) < 2) {
        -: 2759:            /* Most likely this is a connected UNIX-domain client which
        -: 2760:             * has no peer socket address, but there's no portable way
        -: 2761:             * to tell for sure.
        -: 2762:             */
        -: 2763:            sprintf(addr_text, "<AF %d>", af);
        -: 2764:        }
        -: 2765:
       14: 2766:        if (port) {
       11: 2767:            sprintf(buf, "%s:%s:%u", protoname, addr_text, port);
        -: 2768:        } else {
        -: 2769:            sprintf(buf, "%s:%s", protoname, addr_text);
        -: 2770:        }
        -: 2771:    }
       14: 2772:}
        -: 2773:
        2: 2774:static void process_stats_conns(ADD_STAT add_stats, void *c) {
        -: 2775:    int i;
        -: 2776:    char key_str[STAT_KEY_LEN];
        -: 2777:    char val_str[STAT_VAL_LEN];
        -: 2778:    char conn_name[MAXPATHLEN + sizeof("unix:")];
        2: 2779:    int klen = 0, vlen = 0;
        -: 2780:
        2: 2781:    assert(add_stats);
        -: 2782:
     2048: 2783:    for (i = 0; i < max_fds; i++) {
     2048: 2784:        if (conns[i]) {
        -: 2785:            /* This is safe to do unlocked because conns are never freed; the
        -: 2786:             * worst that'll happen will be a minor inconsistency in the
        -: 2787:             * output -- not worth the complexity of the locking that'd be
        -: 2788:             * required to prevent it.
        -: 2789:             */
       14: 2790:            if (conns[i]->state != conn_closed) {
       14: 2791:                conn_to_str(conns[i], conn_name);
        -: 2792:
       28: 2793:                APPEND_NUM_STAT(i, "addr", "%s", conn_name);
       42: 2794:                APPEND_NUM_STAT(i, "state", "%s",
        -: 2795:                        state_text(conns[i]->state));
       28: 2796:                APPEND_NUM_STAT(i, "secs_since_last_cmd", "%d",
        -: 2797:                        current_time - conns[i]->last_cmd_time);
        -: 2798:            }
        -: 2799:        }
        -: 2800:    }
        2: 2801:}
        -: 2802:
     3881: 2803:static void process_stat(conn *c, token_t *tokens, const size_t ntokens) {
     3881: 2804:    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;
     3881: 2805:    assert(c != NULL);
        -: 2806:
     3881: 2807:    if (ntokens < 2) {
    #####: 2808:        out_string(c, "CLIENT_ERROR bad command line");
    #####: 2809:        return;
        -: 2810:    }
        -: 2811:
     3881: 2812:    if (ntokens == 2) {
     3818: 2813:        server_stats(&append_stats, c);
     3817: 2814:        (void)get_stats(NULL, 0, &append_stats, c);
       63: 2815:    } else if (strcmp(subcommand, "reset") == 0) {
        3: 2816:        stats_reset();
        3: 2817:        out_string(c, "RESET");
        3: 2818:        return ;
       60: 2819:    } else if (strcmp(subcommand, "detail") == 0) {
        -: 2820:        /* NOTE: how to tackle detail with binary? */
       10: 2821:        if (ntokens < 4)
    #####: 2822:            process_stats_detail(c, "");  /* outputs the error message */
        -: 2823:        else
       10: 2824:            process_stats_detail(c, tokens[2].value);
        -: 2825:        /* Output already generated */
        -: 2826:        return ;
       50: 2827:    } else if (strcmp(subcommand, "settings") == 0) {
       15: 2828:        process_stat_settings(&append_stats, c);
       35: 2829:    } else if (strcmp(subcommand, "cachedump") == 0) {
        -: 2830:        char *buf;
        3: 2831:        unsigned int bytes, id, limit = 0;
        -: 2832:
        3: 2833:        if (ntokens < 5) {
    #####: 2834:            out_string(c, "CLIENT_ERROR bad command line");
    #####: 2835:            return;
        -: 2836:        }
        -: 2837:
        6: 2838:        if (!safe_strtoul(tokens[2].value, &id) ||
        3: 2839:            !safe_strtoul(tokens[3].value, &limit)) {
    #####: 2840:            out_string(c, "CLIENT_ERROR bad command line format");
    #####: 2841:            return;
        -: 2842:        }
        -: 2843:
        3: 2844:        if (id >= MAX_NUMBER_OF_SLAB_CLASSES-1) {
        1: 2845:            out_string(c, "CLIENT_ERROR Illegal slab id");
        1: 2846:            return;
        -: 2847:        }
        -: 2848:
        2: 2849:        buf = item_cachedump(id, limit, &bytes);
        2: 2850:        write_and_free(c, buf, bytes);
        2: 2851:        return ;
       32: 2852:    } else if (strcmp(subcommand, "conns") == 0) {
        2: 2853:        process_stats_conns(&append_stats, c);
        -: 2854:    } else {
        -: 2855:        /* getting here means that the subcommand is either engine specific or
        -: 2856:           is invalid. query the engine and see. */
       30: 2857:        if (get_stats(subcommand, strlen(subcommand), &append_stats, c)) {
       30: 2858:            if (c->stats.buffer == NULL) {
    #####: 2859:                out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 2860:            } else {
       30: 2861:                write_and_free(c, c->stats.buffer, c->stats.offset);
       30: 2862:                c->stats.buffer = NULL;
        -: 2863:            }
        -: 2864:        } else {
    #####: 2865:            out_string(c, "ERROR");
        -: 2866:        }
        -: 2867:        return ;
        -: 2868:    }
        -: 2869:
        -: 2870:    /* append terminator and start the transfer */
     3833: 2871:    append_stats(NULL, 0, NULL, 0, c);
        -: 2872:
     3833: 2873:    if (c->stats.buffer == NULL) {
    #####: 2874:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 2875:    } else {
     3833: 2876:        write_and_free(c, c->stats.buffer, c->stats.offset);
     3833: 2877:        c->stats.buffer = NULL;
        -: 2878:    }
        -: 2879:}
        -: 2880:
        -: 2881:/* ntokens is overwritten here... shrug.. */
     5842: 2882:static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {
        -: 2883:    char *key;
        -: 2884:    size_t nkey;
     5842: 2885:    int i = 0;
        -: 2886:    item *it;
     5842: 2887:    token_t *key_token = &tokens[KEY_TOKEN];
        -: 2888:    char *suffix;
     5842: 2889:    assert(c != NULL);
        -: 2890:
        -: 2891:    do {
    12645: 2892:        while(key_token->length != 0) {
        -: 2893:
     6684: 2894:            key = key_token->value;
     6684: 2895:            nkey = key_token->length;
        -: 2896:
     6684: 2897:            if(nkey > KEY_MAX_LENGTH) {
        1: 2898:                out_string(c, "CLIENT_ERROR bad command line format");
        2: 2899:                while (i-- > 0) {
        1: 2900:                    item_remove(*(c->ilist + i));
        -: 2901:                }
        -: 2902:                return;
        -: 2903:            }
        -: 2904:
     6683: 2905:            it = item_get(key, nkey);
     6683: 2906:            if (settings.detail_enabled) {
        3: 2907:                stats_prefix_record_get(key, nkey, NULL != it);
        -: 2908:            }
     6683: 2909:            if (it) {
     5798: 2910:                if (i >= c->isize) {
    #####: 2911:                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);
    #####: 2912:                    if (new_list) {
    #####: 2913:                        c->isize *= 2;
    #####: 2914:                        c->ilist = new_list;
        -: 2915:                    } else {
    #####: 2916:                        STATS_LOCK();
    #####: 2917:                        stats.malloc_fails++;
    #####: 2918:                        STATS_UNLOCK();
    #####: 2919:                        item_remove(it);
        -: 2920:                        break;
        -: 2921:                    }
        -: 2922:                }
        -: 2923:
        -: 2924:                /*
        -: 2925:                 * Construct the response. Each hit adds three elements to the
        -: 2926:                 * outgoing data list:
        -: 2927:                 *   "VALUE "
        -: 2928:                 *   key
        -: 2929:                 *   " " + flags + " " + data length + "\r\n" + data (with \r\n)
        -: 2930:                 */
        -: 2931:
     5798: 2932:                if (return_cas)
        -: 2933:                {
        -: 2934:                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
        -: 2935:                                        it->nbytes, ITEM_get_cas(it));
        -: 2936:                  /* Goofy mid-flight realloc. */
       17: 2937:                  if (i >= c->suffixsize) {
    #####: 2938:                    char **new_suffix_list = realloc(c->suffixlist,
        -: 2939:                                           sizeof(char *) * c->suffixsize * 2);
    #####: 2940:                    if (new_suffix_list) {
    #####: 2941:                        c->suffixsize *= 2;
    #####: 2942:                        c->suffixlist  = new_suffix_list;
        -: 2943:                    } else {
    #####: 2944:                        STATS_LOCK();
    #####: 2945:                        stats.malloc_fails++;
    #####: 2946:                        STATS_UNLOCK();
    #####: 2947:                        item_remove(it);
        -: 2948:                        break;
        -: 2949:                    }
        -: 2950:                  }
        -: 2951:
       17: 2952:                  suffix = cache_alloc(c->thread->suffix_cache);
       17: 2953:                  if (suffix == NULL) {
    #####: 2954:                      STATS_LOCK();
    #####: 2955:                      stats.malloc_fails++;
    #####: 2956:                      STATS_UNLOCK();
    #####: 2957:                      out_of_memory(c, "SERVER_ERROR out of memory making CAS suffix");
    #####: 2958:                      item_remove(it);
    #####: 2959:                      while (i-- > 0) {
    #####: 2960:                          item_remove(*(c->ilist + i));
        -: 2961:                      }
        -: 2962:                      return;
        -: 2963:                  }
       17: 2964:                  *(c->suffixlist + i) = suffix;
       34: 2965:                  int suffix_len = snprintf(suffix, SUFFIX_SIZE,
        -: 2966:                                            " %llu\r\n",
       17: 2967:                                            (unsigned long long)ITEM_get_cas(it));
       34: 2968:                  if (add_iov(c, "VALUE ", 6) != 0 ||
       34: 2969:                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||
       34: 2970:                      add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0 ||
       34: 2971:                      add_iov(c, suffix, suffix_len) != 0 ||
       17: 2972:                      add_iov(c, ITEM_data(it), it->nbytes) != 0)
        -: 2973:                      {
    #####: 2974:                          item_remove(it);
        -: 2975:                          break;
        -: 2976:                      }
        -: 2977:                }
        -: 2978:                else
        -: 2979:                {
        -: 2980:                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
        -: 2981:                                        it->nbytes, ITEM_get_cas(it));
    11562: 2982:                  if (add_iov(c, "VALUE ", 6) != 0 ||
    11562: 2983:                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||
     5781: 2984:                      add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)
        -: 2985:                      {
    #####: 2986:                          item_remove(it);
        -: 2987:                          break;
        -: 2988:                      }
        -: 2989:                }
        -: 2990:
        -: 2991:
     5798: 2992:                if (settings.verbose > 1) {
        -: 2993:                    int ii;
    #####: 2994:                    fprintf(stderr, ">%d sending key ", c->sfd);
    #####: 2995:                    for (ii = 0; ii < it->nkey; ++ii) {
    #####: 2996:                        fprintf(stderr, "%c", key[ii]);
        -: 2997:                    }
    #####: 2998:                    fprintf(stderr, "\n");
        -: 2999:                }
        -: 3000:
        -: 3001:                /* item_get() has incremented it->refcount for us */
     5798: 3002:                pthread_mutex_lock(&c->thread->stats.mutex);
     5798: 3003:                c->thread->stats.slab_stats[ITEM_clsid(it)].get_hits++;
     5798: 3004:                c->thread->stats.get_cmds++;
     5798: 3005:                pthread_mutex_unlock(&c->thread->stats.mutex);
     5798: 3006:                item_update(it);
     5798: 3007:                *(c->ilist + i) = it;
     5798: 3008:                i++;
        -: 3009:
        -: 3010:            } else {
      885: 3011:                pthread_mutex_lock(&c->thread->stats.mutex);
      885: 3012:                c->thread->stats.get_misses++;
      885: 3013:                c->thread->stats.get_cmds++;
      885: 3014:                pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3015:                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
        -: 3016:            }
        -: 3017:
     6683: 3018:            key_token++;
        -: 3019:        }
        -: 3020:
        -: 3021:        /*
        -: 3022:         * If the command string hasn't been fully processed, get the next set
        -: 3023:         * of tokens.
        -: 3024:         */
     5961: 3025:        if(key_token->value != NULL) {
      120: 3026:            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);
      120: 3027:            key_token = tokens;
        -: 3028:        }
        -: 3029:
     5961: 3030:    } while(key_token->value != NULL);
        -: 3031:
     5841: 3032:    c->icurr = c->ilist;
     5841: 3033:    c->ileft = i;
     5841: 3034:    if (return_cas) {
       18: 3035:        c->suffixcurr = c->suffixlist;
       18: 3036:        c->suffixleft = i;
        -: 3037:    }
        -: 3038:
     5841: 3039:    if (settings.verbose > 1)
    #####: 3040:        fprintf(stderr, ">%d END\n", c->sfd);
        -: 3041:
        -: 3042:    /*
        -: 3043:        If the loop was terminated because of out-of-memory, it is not
        -: 3044:        reliable to add END\r\n to the buffer, because it might not end
        -: 3045:        in \r\n. So we send SERVER_ERROR instead.
        -: 3046:    */
     5841: 3047:    if (key_token->value != NULL || add_iov(c, "END\r\n", 5) != 0
     5841: 3048:        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {
    #####: 3049:        out_of_memory(c, "SERVER_ERROR out of memory writing get response");
        -: 3050:    }
        -: 3051:    else {
     5841: 3052:        conn_set_state(c, conn_mwrite);
     5841: 3053:        c->msgcurr = 0;
        -: 3054:    }
        -: 3055:}
        -: 3056:
    32775: 3057:static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {
        -: 3058:    char *key;
        -: 3059:    size_t nkey;
        -: 3060:    unsigned int flags;
    32775: 3061:    int32_t exptime_int = 0;
        -: 3062:    time_t exptime;
        -: 3063:    int vlen;
    32775: 3064:    uint64_t req_cas_id=0;
        -: 3065:    item *it;
        -: 3066:
    32775: 3067:    assert(c != NULL);
        -: 3068:
    32775: 3069:    set_noreply_maybe(c, tokens, ntokens);
        -: 3070:
    32775: 3071:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 3072:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3073:        return;
        -: 3074:    }
        -: 3075:
    32775: 3076:    key = tokens[KEY_TOKEN].value;
    32775: 3077:    nkey = tokens[KEY_TOKEN].length;
        -: 3078:
    65548: 3079:    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)
    32774: 3080:           && safe_strtol(tokens[3].value, &exptime_int)
    32773: 3081:           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {
        3: 3082:        out_string(c, "CLIENT_ERROR bad command line format");
        3: 3083:        return;
        -: 3084:    }
        -: 3085:
        -: 3086:    /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */
    32772: 3087:    exptime = exptime_int;
        -: 3088:
        -: 3089:    /* Negative exptimes can underflow and end up immortal. realtime() will
        -: 3090:       immediately expire values that are greater than REALTIME_MAXDELTA, but less
        -: 3091:       than process_started, so lets aim for that. */
    32772: 3092:    if (exptime < 0)
    #####: 3093:        exptime = REALTIME_MAXDELTA + 1;
        -: 3094:
        -: 3095:    // does cas value exist?
    32772: 3096:    if (handle_cas) {
       13: 3097:        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {
        1: 3098:            out_string(c, "CLIENT_ERROR bad command line format");
        1: 3099:            return;
        -: 3100:        }
        -: 3101:    }
        -: 3102:
    32771: 3103:    vlen += 2;
    32771: 3104:    if (vlen < 0 || vlen - 2 < 0) {
        3: 3105:        out_string(c, "CLIENT_ERROR bad command line format");
        3: 3106:        return;
        -: 3107:    }
        -: 3108:
    32768: 3109:    if (settings.detail_enabled) {
      101: 3110:        stats_prefix_record_set(key, nkey);
        -: 3111:    }
        -: 3112:
    65536: 3113:    it = item_alloc(key, nkey, flags, realtime(exptime), vlen);
        -: 3114:
    32768: 3115:    if (it == 0) {
       19: 3116:        if (! item_size_ok(nkey, flags, vlen))
        3: 3117:            out_string(c, "SERVER_ERROR object too large for cache");
        -: 3118:        else
       16: 3119:            out_of_memory(c, "SERVER_ERROR out of memory storing object");
        -: 3120:        /* swallow the data line */
       19: 3121:        c->write_and_go = conn_swallow;
       19: 3122:        c->sbytes = vlen;
        -: 3123:
        -: 3124:        /* Avoid stale data persisting in cache because we failed alloc.
        -: 3125:         * Unacceptable for SET. Anywhere else too? */
       19: 3126:        if (comm == NREAD_SET) {
       19: 3127:            it = item_get(key, nkey);
       19: 3128:            if (it) {
        2: 3129:                item_unlink(it);
        2: 3130:                item_remove(it);
        -: 3131:            }
        -: 3132:        }
        -: 3133:
        -: 3134:        return;
        -: 3135:    }
    32749: 3136:    ITEM_set_cas(it, req_cas_id);
        -: 3137:
    32749: 3138:    c->item = it;
    32749: 3139:    c->ritem = ITEM_data(it);
    32749: 3140:    c->rlbytes = it->nbytes;
    32749: 3141:    c->cmd = comm;
    32749: 3142:    conn_set_state(c, conn_nread);
        -: 3143:}
        -: 3144:
        1: 3145:static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {
        -: 3146:    char *key;
        -: 3147:    size_t nkey;
        1: 3148:    int32_t exptime_int = 0;
        -: 3149:    item *it;
        -: 3150:
        1: 3151:    assert(c != NULL);
        -: 3152:
        1: 3153:    set_noreply_maybe(c, tokens, ntokens);
        -: 3154:
        1: 3155:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 3156:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3157:        return;
        -: 3158:    }
        -: 3159:
        1: 3160:    key = tokens[KEY_TOKEN].value;
        1: 3161:    nkey = tokens[KEY_TOKEN].length;
        -: 3162:
        1: 3163:    if (!safe_strtol(tokens[2].value, &exptime_int)) {
    #####: 3164:        out_string(c, "CLIENT_ERROR invalid exptime argument");
    #####: 3165:        return;
        -: 3166:    }
        -: 3167:
        2: 3168:    it = item_touch(key, nkey, realtime(exptime_int));
        1: 3169:    if (it) {
        1: 3170:        item_update(it);
        1: 3171:        pthread_mutex_lock(&c->thread->stats.mutex);
        1: 3172:        c->thread->stats.touch_cmds++;
        1: 3173:        c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        1: 3174:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3175:
        1: 3176:        out_string(c, "TOUCHED");
        1: 3177:        item_remove(it);
        -: 3178:    } else {
    #####: 3179:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 3180:        c->thread->stats.touch_cmds++;
    #####: 3181:        c->thread->stats.touch_misses++;
    #####: 3182:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3183:
    #####: 3184:        out_string(c, "NOT_FOUND");
        -: 3185:    }
        -: 3186:}
        -: 3187:
      272: 3188:static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
        -: 3189:    char temp[INCR_MAX_STORAGE_LEN];
        -: 3190:    uint64_t delta;
        -: 3191:    char *key;
        -: 3192:    size_t nkey;
        -: 3193:
      272: 3194:    assert(c != NULL);
        -: 3195:
      272: 3196:    set_noreply_maybe(c, tokens, ntokens);
        -: 3197:
      272: 3198:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 3199:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3200:        return;
        -: 3201:    }
        -: 3202:
      272: 3203:    key = tokens[KEY_TOKEN].value;
      272: 3204:    nkey = tokens[KEY_TOKEN].length;
        -: 3205:
      272: 3206:    if (!safe_strtoull(tokens[2].value, &delta)) {
    #####: 3207:        out_string(c, "CLIENT_ERROR invalid numeric delta argument");
    #####: 3208:        return;
        -: 3209:    }
        -: 3210:
      272: 3211:    switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {
        -: 3212:    case OK:
      267: 3213:        out_string(c, temp);
      267: 3214:        break;
        -: 3215:    case NON_NUMERIC:
        1: 3216:        out_string(c, "CLIENT_ERROR cannot increment or decrement non-numeric value");
        1: 3217:        break;
        -: 3218:    case EOM:
    #####: 3219:        out_of_memory(c, "SERVER_ERROR out of memory");
    #####: 3220:        break;
        -: 3221:    case DELTA_ITEM_NOT_FOUND:
        4: 3222:        pthread_mutex_lock(&c->thread->stats.mutex);
        4: 3223:        if (incr) {
        1: 3224:            c->thread->stats.incr_misses++;
        -: 3225:        } else {
        3: 3226:            c->thread->stats.decr_misses++;
        -: 3227:        }
        4: 3228:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3229:
        4: 3230:        out_string(c, "NOT_FOUND");
        4: 3231:        break;
        -: 3232:    case DELTA_ITEM_CAS_MISMATCH:
        -: 3233:        break; /* Should never get here */
        -: 3234:    }
        -: 3235:}
        -: 3236:
        -: 3237:/*
        -: 3238: * adds a delta value to a numeric item.
        -: 3239: *
        -: 3240: * c     connection requesting the operation
        -: 3241: * it    item to adjust
        -: 3242: * incr  true to increment value, false to decrement
        -: 3243: * delta amount to adjust value by
        -: 3244: * buf   buffer for response string
        -: 3245: *
        -: 3246: * returns a response string to send back to the client.
        -: 3247: */
      400: 3248:enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,
        -: 3249:                                    const bool incr, const int64_t delta,
        -: 3250:                                    char *buf, uint64_t *cas,
        -: 3251:                                    const uint32_t hv) {
        -: 3252:    char *ptr;
        -: 3253:    uint64_t value;
        -: 3254:    int res;
        -: 3255:    item *it;
        -: 3256:
      400: 3257:    it = do_item_get(key, nkey, hv);
      400: 3258:    if (!it) {
        -: 3259:        return DELTA_ITEM_NOT_FOUND;
        -: 3260:    }
        -: 3261:
        -: 3262:    /* Can't delta zero byte values. 2-byte are the "\r\n" */
      327: 3263:    if (it->nbytes <= 2) {
        -: 3264:        return NON_NUMERIC;
        -: 3265:    }
        -: 3266:
      327: 3267:    if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {
    #####: 3268:        do_item_remove(it);
    #####: 3269:        return DELTA_ITEM_CAS_MISMATCH;
        -: 3270:    }
        -: 3271:
      327: 3272:    ptr = ITEM_data(it);
        -: 3273:
      327: 3274:    if (!safe_strtoull(ptr, &value)) {
        4: 3275:        do_item_remove(it);
        4: 3276:        return NON_NUMERIC;
        -: 3277:    }
        -: 3278:
      323: 3279:    if (incr) {
      291: 3280:        value += delta;
        -: 3281:        MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 3282:    } else {
       32: 3283:        if(delta > value) {
        4: 3284:            value = 0;
        -: 3285:        } else {
       28: 3286:            value -= delta;
        -: 3287:        }
        -: 3288:        MEMCACHED_COMMAND_DECR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 3289:    }
        -: 3290:
      323: 3291:    pthread_mutex_lock(&c->thread->stats.mutex);
      323: 3292:    if (incr) {
      291: 3293:        c->thread->stats.slab_stats[ITEM_clsid(it)].incr_hits++;
        -: 3294:    } else {
       32: 3295:        c->thread->stats.slab_stats[ITEM_clsid(it)].decr_hits++;
        -: 3296:    }
      323: 3297:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3298:
      323: 3299:    snprintf(buf, INCR_MAX_STORAGE_LEN, "%llu", (unsigned long long)value);
      323: 3300:    res = strlen(buf);
        -: 3301:    /* refcount == 2 means we are the only ones holding the item, and it is
        -: 3302:     * linked. We hold the item's lock in this function, so refcount cannot
        -: 3303:     * increase. */
      323: 3304:    if (res + 2 <= it->nbytes && it->refcount == 2) { /* replace in-place */
        -: 3305:        /* When changing the value without replacing the item, we
        -: 3306:           need to update the CAS on the existing item. */
       69: 3307:        ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
        -: 3308:
       69: 3309:        memcpy(ITEM_data(it), buf, res);
       69: 3310:        memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);
       69: 3311:        do_item_update(it);
      254: 3312:    } else if (it->refcount > 1) {
        -: 3313:        item *new_it;
      508: 3314:        new_it = do_item_alloc(ITEM_key(it), it->nkey, atoi(ITEM_suffix(it) + 1), it->exptime, res + 2, hv);
      254: 3315:        if (new_it == 0) {
    #####: 3316:            do_item_remove(it);
    #####: 3317:            return EOM;
        -: 3318:        }
      254: 3319:        memcpy(ITEM_data(new_it), buf, res);
      254: 3320:        memcpy(ITEM_data(new_it) + res, "\r\n", 2);
      254: 3321:        item_replace(it, new_it, hv);
        -: 3322:        // Overwrite the older item's CAS with our new CAS since we're
        -: 3323:        // returning the CAS of the old item below.
      254: 3324:        ITEM_set_cas(it, (settings.use_cas) ? ITEM_get_cas(new_it) : 0);
      254: 3325:        do_item_remove(new_it);       /* release our reference */
        -: 3326:    } else {
        -: 3327:        /* Should never get here. This means we somehow fetched an unlinked
        -: 3328:         * item. TODO: Add a counter? */
    #####: 3329:        if (settings.verbose) {
    #####: 3330:            fprintf(stderr, "Tried to do incr/decr on invalid item\n");
        -: 3331:        }
    #####: 3332:        if (it->refcount == 1)
    #####: 3333:            do_item_remove(it);
        -: 3334:        return DELTA_ITEM_NOT_FOUND;
        -: 3335:    }
        -: 3336:
      323: 3337:    if (cas) {
       56: 3338:        *cas = ITEM_get_cas(it);    /* swap the incoming CAS value */
        -: 3339:    }
      323: 3340:    do_item_remove(it);         /* release our reference */
      323: 3341:    return OK;
        -: 3342:}
        -: 3343:
     2520: 3344:static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {
        -: 3345:    char *key;
        -: 3346:    size_t nkey;
        -: 3347:    item *it;
        -: 3348:
     2520: 3349:    assert(c != NULL);
        -: 3350:
     2520: 3351:    if (ntokens > 3) {
     2507: 3352:        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, "0") == 0;
     2507: 3353:        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);
     5012: 3354:        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))
     2510: 3355:            || (ntokens == 5 && hold_is_zero && sets_noreply);
     2507: 3356:        if (!valid) {
        2: 3357:            out_string(c, "CLIENT_ERROR bad command line format.  "
        -: 3358:                       "Usage: delete <key> [noreply]");
        2: 3359:            return;
        -: 3360:        }
        -: 3361:    }
        -: 3362:
        -: 3363:
     2518: 3364:    key = tokens[KEY_TOKEN].value;
     2518: 3365:    nkey = tokens[KEY_TOKEN].length;
        -: 3366:
     2518: 3367:    if(nkey > KEY_MAX_LENGTH) {
    #####: 3368:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3369:        return;
        -: 3370:    }
        -: 3371:
     2518: 3372:    if (settings.detail_enabled) {
        1: 3373:        stats_prefix_record_delete(key, nkey);
        -: 3374:    }
        -: 3375:
     2518: 3376:    it = item_get(key, nkey);
     2518: 3377:    if (it) {
        -: 3378:        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
        -: 3379:
     2514: 3380:        pthread_mutex_lock(&c->thread->stats.mutex);
     2514: 3381:        c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
     2514: 3382:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3383:
     2514: 3384:        item_unlink(it);
     2514: 3385:        item_remove(it);      /* release our reference */
     2514: 3386:        out_string(c, "DELETED");
        -: 3387:    } else {
        4: 3388:        pthread_mutex_lock(&c->thread->stats.mutex);
        4: 3389:        c->thread->stats.delete_misses++;
        4: 3390:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3391:
        4: 3392:        out_string(c, "NOT_FOUND");
        -: 3393:    }
        -: 3394:}
        -: 3395:
        1: 3396:static void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {
        -: 3397:    unsigned int level;
        -: 3398:
        1: 3399:    assert(c != NULL);
        -: 3400:
        1: 3401:    set_noreply_maybe(c, tokens, ntokens);
        -: 3402:
        1: 3403:    level = strtoul(tokens[1].value, NULL, 10);
        1: 3404:    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;
        1: 3405:    out_string(c, "OK");
        1: 3406:    return;
        -: 3407:}
        -: 3408:
    #####: 3409:static void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {
        -: 3410:    unsigned int level;
        -: 3411:
    #####: 3412:    assert(c != NULL);
        -: 3413:
    #####: 3414:    set_noreply_maybe(c, tokens, ntokens);
        -: 3415:
    #####: 3416:    level = strtoul(tokens[2].value, NULL, 10);
    #####: 3417:    if (level == 0) {
    #####: 3418:        settings.slab_automove = 0;
    #####: 3419:    } else if (level == 1 || level == 2) {
    #####: 3420:        settings.slab_automove = level;
        -: 3421:    } else {
    #####: 3422:        out_string(c, "ERROR");
    #####: 3423:        return;
        -: 3424:    }
    #####: 3425:    out_string(c, "OK");
    #####: 3426:    return;
        -: 3427:}
        -: 3428:
    45318: 3429:static void process_command(conn *c, char *command) {
        -: 3430:
        -: 3431:    token_t tokens[MAX_TOKENS];
        -: 3432:    size_t ntokens;
        -: 3433:    int comm;
        -: 3434:
    45318: 3435:    assert(c != NULL);
        -: 3436:
        -: 3437:    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
        -: 3438:
    45318: 3439:    if (settings.verbose > 1)
    #####: 3440:        fprintf(stderr, "<%d %s\n", c->sfd, command);
        -: 3441:
        -: 3442:    /*
        -: 3443:     * for commands set/add/replace, we build an item and read the data
        -: 3444:     * directly into it, then continue in nread_complete().
        -: 3445:     */
        -: 3446:
    45318: 3447:    c->msgcurr = 0;
    45318: 3448:    c->msgused = 0;
    45318: 3449:    c->iovused = 0;
    45318: 3450:    if (add_msghdr(c) != 0) {
    #####: 3451:        out_of_memory(c, "SERVER_ERROR out of memory preparing response");
    #####: 3452:        return;
        -: 3453:    }
        -: 3454:
    45318: 3455:    ntokens = tokenize_command(command, tokens, MAX_TOKENS);
    86806: 3456:    if (ntokens >= 3 &&
    77152: 3457:        ((strcmp(tokens[COMMAND_TOKEN].value, "get") == 0) ||
    35664: 3458:         (strcmp(tokens[COMMAND_TOKEN].value, "bget") == 0))) {
        -: 3459:
     5824: 3460:        process_get_command(c, tokens, ntokens, false);
        -: 3461:
    72271: 3462:    } else if ((ntokens == 6 || ntokens == 7) &&
    65541: 3463:               ((strcmp(tokens[COMMAND_TOKEN].value, "add") == 0 && (comm = NREAD_ADD)) ||
    32787: 3464:                (strcmp(tokens[COMMAND_TOKEN].value, "set") == 0 && (comm = NREAD_SET)) ||
       43: 3465:                (strcmp(tokens[COMMAND_TOKEN].value, "replace") == 0 && (comm = NREAD_REPLACE)) ||
       39: 3466:                (strcmp(tokens[COMMAND_TOKEN].value, "prepend") == 0 && (comm = NREAD_PREPEND)) ||
       19: 3467:                (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) )) {
        -: 3468:
    32759: 3469:        process_update_command(c, tokens, ntokens, comm, false);
        -: 3470:
     6735: 3471:    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, "cas") == 0 && (comm = NREAD_CAS))) {
        -: 3472:
       16: 3473:        process_update_command(c, tokens, ntokens, comm, true);
        -: 3474:
     6719: 3475:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "incr") == 0)) {
        -: 3476:
      262: 3477:        process_arithmetic_command(c, tokens, ntokens, 1);
        -: 3478:
     6457: 3479:    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, "gets") == 0)) {
        -: 3480:
       18: 3481:        process_get_command(c, tokens, ntokens, true);
        -: 3482:
     6439: 3483:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "decr") == 0)) {
        -: 3484:
       10: 3485:        process_arithmetic_command(c, tokens, ntokens, 0);
        -: 3486:
     6429: 3487:    } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, "delete") == 0)) {
        -: 3488:
     2520: 3489:        process_delete_command(c, tokens, ntokens);
        -: 3490:
     3909: 3491:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "touch") == 0)) {
        -: 3492:
        1: 3493:        process_touch_command(c, tokens, ntokens);
        -: 3494:
     3908: 3495:    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, "stats") == 0)) {
        -: 3496:
     3881: 3497:        process_stat(c, tokens, ntokens);
        -: 3498:
       27: 3499:    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "flush_all") == 0)) {
       11: 3500:        time_t exptime = 0;
       11: 3501:        rel_time_t new_oldest = 0;
        -: 3502:
       11: 3503:        set_noreply_maybe(c, tokens, ntokens);
        -: 3504:
       11: 3505:        pthread_mutex_lock(&c->thread->stats.mutex);
       11: 3506:        c->thread->stats.flush_cmds++;
       11: 3507:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3508:
       11: 3509:        if (!settings.flush_enabled) {
        -: 3510:            // flush_all is not allowed but we log it on stats
        1: 3511:            out_string(c, "CLIENT_ERROR flush_all not allowed");
        1: 3512:            return;
        -: 3513:        }
        -: 3514:
       10: 3515:        if (ntokens != (c->noreply ? 3 : 2)) {
        5: 3516:            exptime = strtol(tokens[1].value, NULL, 10);
        5: 3517:            if(errno == ERANGE) {
    #####: 3518:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3519:                return;
        -: 3520:            }
        -: 3521:        }
        -: 3522:
        -: 3523:        /*
        -: 3524:          If exptime is zero realtime() would return zero too, and
        -: 3525:          realtime(exptime) - 1 would overflow to the max unsigned
        -: 3526:          value.  So we process exptime == 0 the same way we do when
        -: 3527:          no delay is given at all.
        -: 3528:        */
       10: 3529:        if (exptime > 0) {
        2: 3530:            new_oldest = realtime(exptime);
        -: 3531:        } else { /* exptime == 0 */
        8: 3532:            new_oldest = current_time;
        -: 3533:        }
        -: 3534:
       10: 3535:        if (settings.use_cas) {
        9: 3536:            settings.oldest_live = new_oldest - 1;
        9: 3537:            if (settings.oldest_live <= current_time)
        7: 3538:                settings.oldest_cas = get_cas_id();
        -: 3539:        } else {
        1: 3540:            settings.oldest_live = new_oldest;
        -: 3541:        }
       10: 3542:        out_string(c, "OK");
       10: 3543:        return;
        -: 3544:
       16: 3545:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "version") == 0)) {
        -: 3546:
        1: 3547:        out_string(c, "VERSION " VERSION);
        -: 3548:
       15: 3549:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "quit") == 0)) {
        -: 3550:
    #####: 3551:        conn_set_state(c, conn_closing);
        -: 3552:
       15: 3553:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "shutdown") == 0)) {
        -: 3554:
        1: 3555:        if (settings.shutdown_command) {
        1: 3556:            conn_set_state(c, conn_closing);
        1: 3557:            raise(SIGINT);
        -: 3558:        } else {
    #####: 3559:            out_string(c, "ERROR: shutdown not enabled");
        -: 3560:        }
        -: 3561:
       14: 3562:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "slabs") == 0) {
        2: 3563:        if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, "reassign") == 0) {
        -: 3564:            int src, dst, rv;
        -: 3565:
        2: 3566:            if (settings.slab_reassign == false) {
    #####: 3567:                out_string(c, "CLIENT_ERROR slab reassignment disabled");
    #####: 3568:                return;
        -: 3569:            }
        -: 3570:
        2: 3571:            src = strtol(tokens[2].value, NULL, 10);
        2: 3572:            dst = strtol(tokens[3].value, NULL, 10);
        -: 3573:
        2: 3574:            if (errno == ERANGE) {
    #####: 3575:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3576:                return;
        -: 3577:            }
        -: 3578:
        2: 3579:            rv = slabs_reassign(src, dst);
        2: 3580:            switch (rv) {
        -: 3581:            case REASSIGN_OK:
        2: 3582:                out_string(c, "OK");
        2: 3583:                break;
        -: 3584:            case REASSIGN_RUNNING:
    #####: 3585:                out_string(c, "BUSY currently processing reassign request");
    #####: 3586:                break;
        -: 3587:            case REASSIGN_BADCLASS:
    #####: 3588:                out_string(c, "BADCLASS invalid src or dst class id");
    #####: 3589:                break;
        -: 3590:            case REASSIGN_NOSPARE:
    #####: 3591:                out_string(c, "NOSPARE source class has no spare pages");
    #####: 3592:                break;
        -: 3593:            case REASSIGN_SRC_DST_SAME:
    #####: 3594:                out_string(c, "SAME src and dst class are identical");
    #####: 3595:                break;
        -: 3596:            }
        -: 3597:            return;
    #####: 3598:        } else if (ntokens == 4 &&
    #####: 3599:            (strcmp(tokens[COMMAND_TOKEN + 1].value, "automove") == 0)) {
    #####: 3600:            process_slabs_automove_command(c, tokens, ntokens);
        -: 3601:        } else {
    #####: 3602:            out_string(c, "ERROR");
        -: 3603:        }
       12: 3604:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "lru_crawler") == 0) {
        4: 3605:        if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "crawl") == 0) {
        -: 3606:            int rv;
        2: 3607:            if (settings.lru_crawler == false) {
    #####: 3608:                out_string(c, "CLIENT_ERROR lru crawler disabled");
    #####: 3609:                return;
        -: 3610:            }
        -: 3611:
        2: 3612:            rv = lru_crawler_crawl(tokens[2].value);
        2: 3613:            switch(rv) {
        -: 3614:            case CRAWLER_OK:
        2: 3615:                out_string(c, "OK");
        2: 3616:                break;
        -: 3617:            case CRAWLER_RUNNING:
    #####: 3618:                out_string(c, "BUSY currently processing crawler request");
    #####: 3619:                break;
        -: 3620:            case CRAWLER_BADCLASS:
    #####: 3621:                out_string(c, "BADCLASS invalid class id");
    #####: 3622:                break;
        -: 3623:            case CRAWLER_NOTSTARTED:
    #####: 3624:                out_string(c, "NOTSTARTED no items to crawl");
    #####: 3625:                break;
        -: 3626:            }
        -: 3627:            return;
        2: 3628:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "tocrawl") == 0) {
        -: 3629:            uint32_t tocrawl;
    #####: 3630:             if (!safe_strtoul(tokens[2].value, &tocrawl)) {
    #####: 3631:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3632:                return;
        -: 3633:            }
    #####: 3634:            settings.lru_crawler_tocrawl = tocrawl;
    #####: 3635:            out_string(c, "OK");
    #####: 3636:            return;
        2: 3637:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "sleep") == 0) {
        -: 3638:            uint32_t tosleep;
    #####: 3639:            if (!safe_strtoul(tokens[2].value, &tosleep)) {
    #####: 3640:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3641:                return;
        -: 3642:            }
    #####: 3643:            if (tosleep > 1000000) {
    #####: 3644:                out_string(c, "CLIENT_ERROR sleep must be one second or less");
    #####: 3645:                return;
        -: 3646:            }
    #####: 3647:            settings.lru_crawler_sleep = tosleep;
    #####: 3648:            out_string(c, "OK");
    #####: 3649:            return;
        2: 3650:        } else if (ntokens == 3) {
        2: 3651:            if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "enable") == 0)) {
        1: 3652:                if (start_item_crawler_thread() == 0) {
        1: 3653:                    out_string(c, "OK");
        -: 3654:                } else {
    #####: 3655:                    out_string(c, "ERROR failed to start lru crawler thread");
        -: 3656:                }
        1: 3657:            } else if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "disable") == 0)) {
        1: 3658:                if (stop_item_crawler_thread() == 0) {
        1: 3659:                    out_string(c, "OK");
        -: 3660:                } else {
    #####: 3661:                    out_string(c, "ERROR failed to stop lru crawler thread");
        -: 3662:                }
        -: 3663:            } else {
    #####: 3664:                out_string(c, "ERROR");
        -: 3665:            }
        -: 3666:            return;
        -: 3667:        } else {
    #####: 3668:            out_string(c, "ERROR");
        -: 3669:        }
        8: 3670:    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "verbosity") == 0)) {
        1: 3671:        process_verbosity_command(c, tokens, ntokens);
        -: 3672:    } else {
        7: 3673:        out_string(c, "ERROR");
        -: 3674:    }
        -: 3675:    return;
        -: 3676:}
        -: 3677:
        -: 3678:/*
        -: 3679: * if we have a complete line in the buffer, process it.
        -: 3680: */
    69868: 3681:static int try_read_command(conn *c) {
    69868: 3682:    assert(c != NULL);
    69868: 3683:    assert(c->rcurr <= (c->rbuf + c->rsize));
    69868: 3684:    assert(c->rbytes > 0);
        -: 3685:
    69868: 3686:    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {
       91: 3687:        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
       14: 3688:            c->protocol = binary_prot;
        -: 3689:        } else {
       77: 3690:            c->protocol = ascii_prot;
        -: 3691:        }
        -: 3692:
       91: 3693:        if (settings.verbose > 1) {
    #####: 3694:            fprintf(stderr, "%d: Client using the %s protocol\n", c->sfd,
        -: 3695:                    prot_text(c->protocol));
        -: 3696:        }
        -: 3697:    }
        -: 3698:
    69868: 3699:    if (c->protocol == binary_prot) {
        -: 3700:        /* Do we have the complete packet header? */
    24545: 3701:        if (c->rbytes < sizeof(c->binary_header)) {
        -: 3702:            /* need more data! */
        -: 3703:            return 0;
        -: 3704:        } else {
        -: 3705:#ifdef NEED_ALIGN
        -: 3706:            if (((long)(c->rcurr)) % 8 != 0) {
        -: 3707:                /* must realign input buffer */
        -: 3708:                memmove(c->rbuf, c->rcurr, c->rbytes);
        -: 3709:                c->rcurr = c->rbuf;
        -: 3710:                if (settings.verbose > 1) {
        -: 3711:                    fprintf(stderr, "%d: Realign input buffer\n", c->sfd);
        -: 3712:                }
        -: 3713:            }
        -: 3714:#endif
        -: 3715:            protocol_binary_request_header* req;
    24440: 3716:            req = (protocol_binary_request_header*)c->rcurr;
        -: 3717:
    24440: 3718:            if (settings.verbose > 1) {
        -: 3719:                /* Dump the packet before we convert it to host order */
        -: 3720:                int ii;
    #####: 3721:                fprintf(stderr, "<%d Read binary protocol data:", c->sfd);
    #####: 3722:                for (ii = 0; ii < sizeof(req->bytes); ++ii) {
    #####: 3723:                    if (ii % 4 == 0) {
    #####: 3724:                        fprintf(stderr, "\n<%d   ", c->sfd);
        -: 3725:                    }
    #####: 3726:                    fprintf(stderr, " 0x%02x", req->bytes[ii]);
        -: 3727:                }
    #####: 3728:                fprintf(stderr, "\n");
        -: 3729:            }
        -: 3730:
    24440: 3731:            c->binary_header = *req;
    24440: 3732:            c->binary_header.request.keylen = ntohs(req->request.keylen);
    48880: 3733:            c->binary_header.request.bodylen = ntohl(req->request.bodylen);
    24440: 3734:            c->binary_header.request.cas = ntohll(req->request.cas);
        -: 3735:
    24440: 3736:            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {
        1: 3737:                if (settings.verbose) {
    #####: 3738:                    fprintf(stderr, "Invalid magic:  %x\n",
        -: 3739:                            c->binary_header.request.magic);
        -: 3740:                }
        1: 3741:                conn_set_state(c, conn_closing);
        1: 3742:                return -1;
        -: 3743:            }
        -: 3744:
    24439: 3745:            c->msgcurr = 0;
    24439: 3746:            c->msgused = 0;
    24439: 3747:            c->iovused = 0;
    24439: 3748:            if (add_msghdr(c) != 0) {
    #####: 3749:                out_of_memory(c,
        -: 3750:                        "SERVER_ERROR Out of memory allocating headers");
    #####: 3751:                return 0;
        -: 3752:            }
        -: 3753:
    24439: 3754:            c->cmd = c->binary_header.request.opcode;
    24439: 3755:            c->keylen = c->binary_header.request.keylen;
    24439: 3756:            c->opaque = c->binary_header.request.opaque;
        -: 3757:            /* clear the returned cas value */
    24439: 3758:            c->cas = 0;
        -: 3759:
    24439: 3760:            dispatch_bin_command(c);
        -: 3761:
    24439: 3762:            c->rbytes -= sizeof(c->binary_header);
    24439: 3763:            c->rcurr += sizeof(c->binary_header);
        -: 3764:        }
        -: 3765:    } else {
        -: 3766:        char *el, *cont;
        -: 3767:
    45323: 3768:        if (c->rbytes == 0)
        -: 3769:            return 0;
        -: 3770:
    45323: 3771:        el = memchr(c->rcurr, '\n', c->rbytes);
    45323: 3772:        if (!el) {
        5: 3773:            if (c->rbytes > 1024) {
        -: 3774:                /*
        -: 3775:                 * We didn't have a '\n' in the first k. This _has_ to be a
        -: 3776:                 * large multiget, if not we should just nuke the connection.
        -: 3777:                 */
        -: 3778:                char *ptr = c->rcurr;
     4200: 3779:                while (*ptr == ' ') { /* ignore leading whitespaces */
     4196: 3780:                    ++ptr;
        -: 3781:                }
        -: 3782:
        6: 3783:                if (ptr - c->rcurr > 100 ||
        3: 3784:                    (strncmp(ptr, "get ", 4) && strncmp(ptr, "gets ", 5))) {
        -: 3785:
        2: 3786:                    conn_set_state(c, conn_closing);
        2: 3787:                    return 1;
        -: 3788:                }
        -: 3789:            }
        -: 3790:
        -: 3791:            return 0;
        -: 3792:        }
    45318: 3793:        cont = el + 1;
    45318: 3794:        if ((el - c->rcurr) > 1 && *(el - 1) == '\r') {
    45314: 3795:            el--;
        -: 3796:        }
    45318: 3797:        *el = '\0';
        -: 3798:
    45318: 3799:        assert(cont <= (c->rcurr + c->rbytes));
        -: 3800:
    45318: 3801:        c->last_cmd_time = current_time;
    45318: 3802:        process_command(c, c->rcurr);
        -: 3803:
    45315: 3804:        c->rbytes -= (cont - c->rcurr);
    45315: 3805:        c->rcurr = cont;
        -: 3806:
    45315: 3807:        assert(c->rcurr <= (c->rbuf + c->rsize));
        -: 3808:    }
        -: 3809:
        -: 3810:    return 1;
        -: 3811:}
        -: 3812:
        -: 3813:/*
        -: 3814: * read a UDP request.
        -: 3815: */
       17: 3816:static enum try_read_result try_read_udp(conn *c) {
        -: 3817:    int res;
        -: 3818:
       17: 3819:    assert(c != NULL);
        -: 3820:
       17: 3821:    c->request_addr_size = sizeof(c->request_addr);
       51: 3822:    res = recvfrom(c->sfd, c->rbuf, c->rsize,
       17: 3823:                   0, (struct sockaddr *)&c->request_addr,
        -: 3824:                   &c->request_addr_size);
       17: 3825:    if (res > 8) {
       17: 3826:        unsigned char *buf = (unsigned char *)c->rbuf;
       17: 3827:        pthread_mutex_lock(&c->thread->stats.mutex);
       17: 3828:        c->thread->stats.bytes_read += res;
       17: 3829:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3830:
        -: 3831:        /* Beginning of UDP packet is the request ID; save it. */
       17: 3832:        c->request_id = buf[0] * 256 + buf[1];
        -: 3833:
        -: 3834:        /* If this is a multi-packet request, drop it. */
       17: 3835:        if (buf[4] != 0 || buf[5] != 1) {
    #####: 3836:            out_string(c, "SERVER_ERROR multi-packet request not supported");
    #####: 3837:            return READ_NO_DATA_RECEIVED;
        -: 3838:        }
        -: 3839:
        -: 3840:        /* Don't care about any of the rest of the header. */
       17: 3841:        res -= 8;
       17: 3842:        memmove(c->rbuf, c->rbuf + 8, res);
        -: 3843:
       17: 3844:        c->rbytes = res;
       17: 3845:        c->rcurr = c->rbuf;
       17: 3846:        return READ_DATA_RECEIVED;
        -: 3847:    }
        -: 3848:    return READ_NO_DATA_RECEIVED;
        -: 3849:}
        -: 3850:
        -: 3851:/*
        -: 3852: * read from network as much as we can, handle buffer overflow and connection
        -: 3853: * close.
        -: 3854: * before reading, move the remaining incomplete fragment of a command
        -: 3855: * (if any) to the beginning of the buffer.
        -: 3856: *
        -: 3857: * To protect us from someone flooding a connection with bogus data causing
        -: 3858: * the connection to eat up all available memory, break out and start looking
        -: 3859: * at the data I've got after a number of reallocs...
        -: 3860: *
        -: 3861: * @return enum try_read_result
        -: 3862: */
    16096: 3863:static enum try_read_result try_read_network(conn *c) {
    16096: 3864:    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
        -: 3865:    int res;
    16096: 3866:    int num_allocs = 0;
    16096: 3867:    assert(c != NULL);
        -: 3868:
    16096: 3869:    if (c->rcurr != c->rbuf) {
     8907: 3870:        if (c->rbytes != 0) /* otherwise there's nothing to copy */
       52: 3871:            memmove(c->rbuf, c->rcurr, c->rbytes);
     8907: 3872:        c->rcurr = c->rbuf;
        -: 3873:    }
        -: 3874:
        -: 3875:    while (1) {
    50500: 3876:        if (c->rbytes >= c->rsize) {
    34404: 3877:            if (num_allocs == 4) {
        -: 3878:                return gotdata;
        -: 3879:            }
    28982: 3880:            ++num_allocs;
    28982: 3881:            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
    28982: 3882:            if (!new_rbuf) {
    #####: 3883:                STATS_LOCK();
    #####: 3884:                stats.malloc_fails++;
    #####: 3885:                STATS_UNLOCK();
    #####: 3886:                if (settings.verbose > 0) {
    #####: 3887:                    fprintf(stderr, "Couldn't realloc input buffer\n");
        -: 3888:                }
    #####: 3889:                c->rbytes = 0; /* ignore what we read */
    #####: 3890:                out_of_memory(c, "SERVER_ERROR out of memory reading request");
    #####: 3891:                c->write_and_go = conn_closing;
    #####: 3892:                return READ_MEMORY_ERROR;
        -: 3893:            }
    28982: 3894:            c->rcurr = c->rbuf = new_rbuf;
    28982: 3895:            c->rsize *= 2;
        -: 3896:        }
        -: 3897:
    45078: 3898:        int avail = c->rsize - c->rbytes;
    90156: 3899:        res = read(c->sfd, c->rbuf + c->rbytes, avail);
    45078: 3900:        if (res > 0) {
    43229: 3901:            pthread_mutex_lock(&c->thread->stats.mutex);
    43229: 3902:            c->thread->stats.bytes_read += res;
    43229: 3903:            pthread_mutex_unlock(&c->thread->stats.mutex);
    43229: 3904:            gotdata = READ_DATA_RECEIVED;
    43229: 3905:            c->rbytes += res;
    43229: 3906:            if (res == avail) {
    34404: 3907:                continue;
        -: 3908:            } else {
        -: 3909:                break;
        -: 3910:            }
        -: 3911:        }
     1849: 3912:        if (res == 0) {
        -: 3913:            return READ_ERROR;
        -: 3914:        }
     1824: 3915:        if (res == -1) {
     1824: 3916:            if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 3917:                break;
        -: 3918:            }
        -: 3919:            return READ_ERROR;
        -: 3920:        }
        -: 3921:    }
    10649: 3922:    return gotdata;
        -: 3923:}
        -: 3924:
    32398: 3925:static bool update_event(conn *c, const int new_flags) {
    32398: 3926:    assert(c != NULL);
        -: 3927:
    32398: 3928:    struct event_base *base = c->event.ev_base;
    32398: 3929:    if (c->ev_flags == new_flags)
        -: 3930:        return true;
     1156: 3931:    if (event_del(&c->event) == -1) return false;
     1156: 3932:    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);
     1156: 3933:    event_base_set(base, &c->event);
     1156: 3934:    c->ev_flags = new_flags;
     1156: 3935:    if (event_add(&c->event, 0) == -1) return false;
     1156: 3936:    return true;
        -: 3937:}
        -: 3938:
        -: 3939:/*
        -: 3940: * Sets whether we are listening for new connections or not.
        -: 3941: */
    #####: 3942:void do_accept_new_conns(const bool do_accept) {
        -: 3943:    conn *next;
        -: 3944:
    #####: 3945:    for (next = listen_conn; next; next = next->next) {
    #####: 3946:        if (do_accept) {
    #####: 3947:            update_event(next, EV_READ | EV_PERSIST);
    #####: 3948:            if (listen(next->sfd, settings.backlog) != 0) {
    #####: 3949:                perror("listen");
        -: 3950:            }
        -: 3951:        }
        -: 3952:        else {
    #####: 3953:            update_event(next, 0);
    #####: 3954:            if (listen(next->sfd, 0) != 0) {
    #####: 3955:                perror("listen");
        -: 3956:            }
        -: 3957:        }
        -: 3958:    }
        -: 3959:
    #####: 3960:    if (do_accept) {
        -: 3961:        struct timeval maxconns_exited;
        -: 3962:        uint64_t elapsed_us;
    #####: 3963:        gettimeofday(&maxconns_exited,NULL);
    #####: 3964:        STATS_LOCK();
    #####: 3965:        elapsed_us =
    #####: 3966:            (maxconns_exited.tv_sec - stats.maxconns_entered.tv_sec) * 1000000
    #####: 3967:            + (maxconns_exited.tv_usec - stats.maxconns_entered.tv_usec);
    #####: 3968:        stats.time_in_listen_disabled_us += elapsed_us;
    #####: 3969:        stats.accepting_conns = true;
    #####: 3970:        STATS_UNLOCK();
        -: 3971:    } else {
    #####: 3972:        STATS_LOCK();
    #####: 3973:        stats.accepting_conns = false;
    #####: 3974:        gettimeofday(&stats.maxconns_entered,NULL);
    #####: 3975:        stats.listen_disabled_num++;
    #####: 3976:        STATS_UNLOCK();
    #####: 3977:        allow_new_conns = false;
    #####: 3978:        maxconns_handler(-42, 0, 0);
        -: 3979:    }
    #####: 3980:}
        -: 3981:
        -: 3982:/*
        -: 3983: * Transmit the next chunk of data from our list of msgbuf structures.
        -: 3984: *
        -: 3985: * Returns:
        -: 3986: *   TRANSMIT_COMPLETE   All done writing.
        -: 3987: *   TRANSMIT_INCOMPLETE More data remaining to write.
        -: 3988: *   TRANSMIT_SOFT_ERROR Can't write any more right now.
        -: 3989: *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)
        -: 3990: */
    39794: 3991:static enum transmit_result transmit(conn *c) {
    39794: 3992:    assert(c != NULL);
        -: 3993:
    79588: 3994:    if (c->msgcurr < c->msgused &&
    39794: 3995:            c->msglist[c->msgcurr].msg_iovlen == 0) {
        -: 3996:        /* Finished writing the current msg; advance to the next. */
    22609: 3997:        c->msgcurr++;
        -: 3998:    }
    39794: 3999:    if (c->msgcurr < c->msgused) {
        -: 4000:        ssize_t res;
    22615: 4001:        struct msghdr *m = &c->msglist[c->msgcurr];
        -: 4002:
    22615: 4003:        res = sendmsg(c->sfd, m, 0);
    22613: 4004:        if (res > 0) {
    22611: 4005:            pthread_mutex_lock(&c->thread->stats.mutex);
    22611: 4006:            c->thread->stats.bytes_written += res;
    22611: 4007:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4008:
        -: 4009:            /* We've written some of the data. Remove the completed
        -: 4010:               iovec entries from the list of pending writes. */
    95275: 4011:            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {
    50053: 4012:                res -= m->msg_iov->iov_len;
    50053: 4013:                m->msg_iovlen--;
    50053: 4014:                m->msg_iov++;
        -: 4015:            }
        -: 4016:
        -: 4017:            /* Might have written just part of the last iovec entry;
        -: 4018:               adjust it so the next write will do the rest. */
    22611: 4019:            if (res > 0) {
        2: 4020:                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;
        2: 4021:                m->msg_iov->iov_len -= res;
        -: 4022:            }
        -: 4023:            return TRANSMIT_INCOMPLETE;
        -: 4024:        }
        2: 4025:        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
        1: 4026:            if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 4027:                if (settings.verbose > 0)
    #####: 4028:                    fprintf(stderr, "Couldn't update event\n");
    #####: 4029:                conn_set_state(c, conn_closing);
    #####: 4030:                return TRANSMIT_HARD_ERROR;
        -: 4031:            }
        -: 4032:            return TRANSMIT_SOFT_ERROR;
        -: 4033:        }
        -: 4034:        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,
        -: 4035:           we have a real error, on which we close the connection */
        1: 4036:        if (settings.verbose > 0)
    #####: 4037:            perror("Failed to write, and not due to blocking");
        -: 4038:
        1: 4039:        if (IS_UDP(c->transport))
    #####: 4040:            conn_set_state(c, conn_read);
        -: 4041:        else
        1: 4042:            conn_set_state(c, conn_closing);
        -: 4043:        return TRANSMIT_HARD_ERROR;
        -: 4044:    } else {
        -: 4045:        return TRANSMIT_COMPLETE;
        -: 4046:    }
        -: 4047:}
        -: 4048:
    32541: 4049:static void drive_machine(conn *c) {
    32541: 4050:    bool stop = false;
        -: 4051:    int sfd;
        -: 4052:    socklen_t addrlen;
        -: 4053:    struct sockaddr_storage addr;
    32541: 4054:    int nreqs = settings.reqs_per_event;
        -: 4055:    int res;
        -: 4056:    const char *str;
        -: 4057:#ifdef HAVE_ACCEPT4
        -: 4058:    static int  use_accept4 = 1;
        -: 4059:#else
        -: 4060:    static int  use_accept4 = 0;
        -: 4061:#endif
        -: 4062:
    32541: 4063:    assert(c != NULL);
        -: 4064:
   421826: 4065:    while (!stop) {
        -: 4066:
   389291: 4067:        switch(c->state) {
        -: 4068:        case conn_listening:
       99: 4069:            addrlen = sizeof(addr);
        -: 4070:#ifdef HAVE_ACCEPT4
       99: 4071:            if (use_accept4) {
       99: 4072:                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);
        -: 4073:            } else {
    #####: 4074:                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 4075:            }
        -: 4076:#else
        -: 4077:            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 4078:#endif
       99: 4079:            if (sfd == -1) {
    #####: 4080:                if (use_accept4 && errno == ENOSYS) {
    #####: 4081:                    use_accept4 = 0;
    #####: 4082:                    continue;
        -: 4083:                }
    #####: 4084:                perror(use_accept4 ? "accept4()" : "accept()");
    #####: 4085:                if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 4086:                    /* these are transient, so don't log anything */
        -: 4087:                    stop = true;
    #####: 4088:                } else if (errno == EMFILE) {
    #####: 4089:                    if (settings.verbose > 0)
    #####: 4090:                        fprintf(stderr, "Too many open connections\n");
    #####: 4091:                    accept_new_conns(false);
    #####: 4092:                    stop = true;
        -: 4093:                } else {
    #####: 4094:                    perror("accept()");
    #####: 4095:                    stop = true;
        -: 4096:                }
        -: 4097:                break;
        -: 4098:            }
       99: 4099:            if (!use_accept4) {
    #####: 4100:                if (fcntl(sfd, F_SETFL, fcntl(sfd, F_GETFL) | O_NONBLOCK) < 0) {
    #####: 4101:                    perror("setting O_NONBLOCK");
    #####: 4102:                    close(sfd);
    #####: 4103:                    break;
        -: 4104:                }
        -: 4105:            }
        -: 4106:
       99: 4107:            if (settings.maxconns_fast &&
    #####: 4108:                stats.curr_conns + stats.reserved_fds >= settings.maxconns - 1) {
    #####: 4109:                str = "ERROR Too many open connections\r\n";
    #####: 4110:                res = write(sfd, str, strlen(str));
    #####: 4111:                close(sfd);
    #####: 4112:                STATS_LOCK();
    #####: 4113:                stats.rejected_conns++;
    #####: 4114:                STATS_UNLOCK();
        -: 4115:            } else {
       99: 4116:                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,
        -: 4117:                                     DATA_BUFFER_SIZE, tcp_transport);
        -: 4118:            }
        -: 4119:
        -: 4120:            stop = true;
        -: 4121:            break;
        -: 4122:
        -: 4123:        case conn_waiting:
    16162: 4124:            if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 4125:                if (settings.verbose > 0)
    #####: 4126:                    fprintf(stderr, "Couldn't update event\n");
    #####: 4127:                conn_set_state(c, conn_closing);
    #####: 4128:                break;
        -: 4129:            }
        -: 4130:
    16162: 4131:            conn_set_state(c, conn_read);
    16162: 4132:            stop = true;
    16162: 4133:            break;
        -: 4134:
        -: 4135:        case conn_read:
    16113: 4136:            res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);
        -: 4137:
    16113: 4138:            switch (res) {
        -: 4139:            case READ_NO_DATA_RECEIVED:
    #####: 4140:                conn_set_state(c, conn_waiting);
    #####: 4141:                break;
        -: 4142:            case READ_DATA_RECEIVED:
    16088: 4143:                conn_set_state(c, conn_parse_cmd);
    16088: 4144:                break;
        -: 4145:            case READ_ERROR:
       25: 4146:                conn_set_state(c, conn_closing);
       25: 4147:                break;
        -: 4148:            case READ_MEMORY_ERROR: /* Failed to allocate more memory */
        -: 4149:                /* State already set by try_read_network */
        -: 4150:                break;
        -: 4151:            }
        -: 4152:            break;
        -: 4153:
        -: 4154:        case conn_parse_cmd :
    69868: 4155:            if (try_read_command(c) == 0) {
        -: 4156:                /* wee need more data! */
      108: 4157:                conn_set_state(c, conn_waiting);
        -: 4158:            }
        -: 4159:
        -: 4160:            break;
        -: 4161:
        -: 4162:        case conn_new_cmd:
        -: 4163:            /* Only process nreqs at a time to avoid starving other
        -: 4164:               connections */
        -: 4165:
    70899: 4166:            --nreqs;
    70899: 4167:            if (nreqs >= 0) {
    69834: 4168:                reset_cmd_handler(c);
        -: 4169:            } else {
     1065: 4170:                pthread_mutex_lock(&c->thread->stats.mutex);
     1065: 4171:                c->thread->stats.conn_yields++;
     1065: 4172:                pthread_mutex_unlock(&c->thread->stats.mutex);
     1065: 4173:                if (c->rbytes > 0) {
        -: 4174:                    /* We have already read in data into the input buffer,
        -: 4175:                       so libevent will most likely not signal read events
        -: 4176:                       on the socket (unless more data is available. As a
        -: 4177:                       hack we should just put in a request to write data,
        -: 4178:                       because that should be possible ;-)
        -: 4179:                    */
     1061: 4180:                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 4181:                        if (settings.verbose > 0)
    #####: 4182:                            fprintf(stderr, "Couldn't update event\n");
    #####: 4183:                        conn_set_state(c, conn_closing);
    #####: 4184:                        break;
        -: 4185:                    }
        -: 4186:                }
        -: 4187:                stop = true;
        -: 4188:            }
        -: 4189:            break;
        -: 4190:
        -: 4191:        case conn_nread:
   175550: 4192:            if (c->rlbytes == 0) {
    73984: 4193:                complete_nread(c);
    73984: 4194:                break;
        -: 4195:            }
        -: 4196:
        -: 4197:            /* Check if rbytes < 0, to prevent crash */
   101566: 4198:            if (c->rlbytes < 0) {
        1: 4199:                if (settings.verbose) {
    #####: 4200:                    fprintf(stderr, "Invalid rlbytes to read: len %d\n", c->rlbytes);
        -: 4201:                }
        1: 4202:                conn_set_state(c, conn_closing);
        1: 4203:                break;
        -: 4204:            }
        -: 4205:
        -: 4206:            /* first check if we have leftovers in the conn_read buffer */
   101565: 4207:            if (c->rbytes > 0) {
    73824: 4208:                int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
    73824: 4209:                if (c->ritem != c->rcurr) {
    52768: 4210:                    memmove(c->ritem, c->rcurr, tocopy);
        -: 4211:                }
    73824: 4212:                c->ritem += tocopy;
    73824: 4213:                c->rlbytes -= tocopy;
    73824: 4214:                c->rcurr += tocopy;
    73824: 4215:                c->rbytes -= tocopy;
    73824: 4216:                if (c->rlbytes == 0) {
        -: 4217:                    break;
        -: 4218:                }
        -: 4219:            }
        -: 4220:
        -: 4221:            /*  now try reading from the socket */
    70934: 4222:            res = read(c->sfd, c->ritem, c->rlbytes);
    35467: 4223:            if (res > 0) {
    20495: 4224:                pthread_mutex_lock(&c->thread->stats.mutex);
    20495: 4225:                c->thread->stats.bytes_read += res;
    20495: 4226:                pthread_mutex_unlock(&c->thread->stats.mutex);
    20495: 4227:                if (c->rcurr == c->ritem) {
       95: 4228:                    c->rcurr += res;
        -: 4229:                }
    20495: 4230:                c->ritem += res;
    20495: 4231:                c->rlbytes -= res;
    20495: 4232:                break;
        -: 4233:            }
    14972: 4234:            if (res == 0) { /* end of stream */
    #####: 4235:                conn_set_state(c, conn_closing);
    #####: 4236:                break;
        -: 4237:            }
    14972: 4238:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    14972: 4239:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 4240:                    if (settings.verbose > 0)
    #####: 4241:                        fprintf(stderr, "Couldn't update event\n");
    #####: 4242:                    conn_set_state(c, conn_closing);
    #####: 4243:                    break;
        -: 4244:                }
        -: 4245:                stop = true;
        -: 4246:                break;
        -: 4247:            }
        -: 4248:            /* otherwise we have a real error, on which we close the connection */
    #####: 4249:            if (settings.verbose > 0) {
    #####: 4250:                fprintf(stderr, "Failed to read, and not due to blocking:\n"
        -: 4251:                        "errno: %d %s \n"
        -: 4252:                        "rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\n",
    #####: 4253:                        errno, strerror(errno),
    #####: 4254:                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,
        -: 4255:                        (int)c->rlbytes, (int)c->rsize);
        -: 4256:            }
    #####: 4257:            conn_set_state(c, conn_closing);
    #####: 4258:            break;
        -: 4259:
        -: 4260:        case conn_swallow:
        -: 4261:            /* we are reading sbytes and throwing them away */
      771: 4262:            if (c->sbytes == 0) {
       20: 4263:                conn_set_state(c, conn_new_cmd);
       20: 4264:                break;
        -: 4265:            }
        -: 4266:
        -: 4267:            /* first check if we have leftovers in the conn_read buffer */
      751: 4268:            if (c->rbytes > 0) {
       20: 4269:                int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;
       20: 4270:                c->sbytes -= tocopy;
       20: 4271:                c->rcurr += tocopy;
       20: 4272:                c->rbytes -= tocopy;
       20: 4273:                break;
        -: 4274:            }
        -: 4275:
        -: 4276:            /*  now try reading from the socket */
     1462: 4277:            res = read(c->sfd, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize);
      731: 4278:            if (res > 0) {
      529: 4279:                pthread_mutex_lock(&c->thread->stats.mutex);
      529: 4280:                c->thread->stats.bytes_read += res;
      529: 4281:                pthread_mutex_unlock(&c->thread->stats.mutex);
      529: 4282:                c->sbytes -= res;
      529: 4283:                break;
        -: 4284:            }
      202: 4285:            if (res == 0) { /* end of stream */
    #####: 4286:                conn_set_state(c, conn_closing);
    #####: 4287:                break;
        -: 4288:            }
      202: 4289:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
      202: 4290:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 4291:                    if (settings.verbose > 0)
    #####: 4292:                        fprintf(stderr, "Couldn't update event\n");
    #####: 4293:                    conn_set_state(c, conn_closing);
    #####: 4294:                    break;
        -: 4295:                }
        -: 4296:                stop = true;
        -: 4297:                break;
        -: 4298:            }
        -: 4299:            /* otherwise we have a real error, on which we close the connection */
    #####: 4300:            if (settings.verbose > 0)
    #####: 4301:                fprintf(stderr, "Failed to read, and not due to blocking\n");
    #####: 4302:            conn_set_state(c, conn_closing);
    #####: 4303:            break;
        -: 4304:
        -: 4305:        case conn_write:
        -: 4306:            /*
        -: 4307:             * We want to write out a simple response. If we haven't already,
        -: 4308:             * assemble it into a msgbuf list (this will be a single-entry
        -: 4309:             * list for TCP or a two-entry list for UDP).
        -: 4310:             */
    13974: 4311:            if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {
     6976: 4312:                if (add_iov(c, c->wcurr, c->wbytes) != 0) {
    #####: 4313:                    if (settings.verbose > 0)
    #####: 4314:                        fprintf(stderr, "Couldn't build response\n");
    #####: 4315:                    conn_set_state(c, conn_closing);
    #####: 4316:                    break;
        -: 4317:                }
        -: 4318:            }
        -: 4319:
        -: 4320:            /* fall through... */
        -: 4321:
        -: 4322:        case conn_mwrite:
    39794: 4323:          if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {
    #####: 4324:            if (settings.verbose > 0)
    #####: 4325:              fprintf(stderr, "Failed to build UDP headers\n");
    #####: 4326:            conn_set_state(c, conn_closing);
    #####: 4327:            break;
        -: 4328:          }
    39794: 4329:            switch (transmit(c)) {
        -: 4330:            case TRANSMIT_COMPLETE:
    17179: 4331:                if (c->state == conn_mwrite) {
    10204: 4332:                    conn_release_items(c);
        -: 4333:                    /* XXX:  I don't know why this wasn't the general case */
    10204: 4334:                    if(c->protocol == binary_prot) {
     4365: 4335:                        conn_set_state(c, c->write_and_go);
        -: 4336:                    } else {
     5839: 4337:                        conn_set_state(c, conn_new_cmd);
        -: 4338:                    }
     6975: 4339:                } else if (c->state == conn_write) {
     6975: 4340:                    if (c->write_and_free) {
     3891: 4341:                        free(c->write_and_free);
     3891: 4342:                        c->write_and_free = 0;
        -: 4343:                    }
     6975: 4344:                    conn_set_state(c, c->write_and_go);
        -: 4345:                } else {
    #####: 4346:                    if (settings.verbose > 0)
    #####: 4347:                        fprintf(stderr, "Unexpected state %d\n", c->state);
    #####: 4348:                    conn_set_state(c, conn_closing);
        -: 4349:                }
        -: 4350:                break;
        -: 4351:
        -: 4352:            case TRANSMIT_INCOMPLETE:
        -: 4353:            case TRANSMIT_HARD_ERROR:
        -: 4354:                break;                   /* Continue in state machine. */
        -: 4355:
        -: 4356:            case TRANSMIT_SOFT_ERROR:
        1: 4357:                stop = true;
        1: 4358:                break;
        -: 4359:            }
        -: 4360:            break;
        -: 4361:
        -: 4362:        case conn_closing:
       35: 4363:            if (IS_UDP(c->transport))
    #####: 4364:                conn_cleanup(c);
        -: 4365:            else
       35: 4366:                conn_close(c);
        -: 4367:            stop = true;
        -: 4368:            break;
        -: 4369:
        -: 4370:        case conn_closed:
        -: 4371:            /* This only happens if dormando is an idiot. */
    #####: 4372:            abort();
        -: 4373:            break;
        -: 4374:
        -: 4375:        case conn_max_state:
    #####: 4376:            assert(false);
        -: 4377:            break;
        -: 4378:        }
        -: 4379:    }
        -: 4380:
    32535: 4381:    return;
        -: 4382:}
        -: 4383:
    32541: 4384:void event_handler(const int fd, const short which, void *arg) {
        -: 4385:    conn *c;
        -: 4386:
    32541: 4387:    c = (conn *)arg;
    32541: 4388:    assert(c != NULL);
        -: 4389:
    32541: 4390:    c->which = which;
        -: 4391:
        -: 4392:    /* sanity */
    32541: 4393:    if (fd != c->sfd) {
    #####: 4394:        if (settings.verbose > 0)
    #####: 4395:            fprintf(stderr, "Catastrophic: event fd doesn't match conn fd!\n");
    #####: 4396:        conn_close(c);
    #####: 4397:        return;
        -: 4398:    }
        -: 4399:
    32541: 4400:    drive_machine(c);
        -: 4401:
        -: 4402:    /* wait for next event */
    32535: 4403:    return;
        -: 4404:}
        -: 4405:
      302: 4406:static int new_socket(struct addrinfo *ai) {
        -: 4407:    int sfd;
        -: 4408:    int flags;
        -: 4409:
      302: 4410:    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {
        -: 4411:        return -1;
        -: 4412:    }
        -: 4413:
      604: 4414:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
      302: 4415:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 4416:        perror("setting O_NONBLOCK");
    #####: 4417:        close(sfd);
        -: 4418:        return -1;
        -: 4419:    }
        -: 4420:    return sfd;
        -: 4421:}
        -: 4422:
        -: 4423:
        -: 4424:/*
        -: 4425: * Sets a socket's send buffer size to the maximum allowed by the system.
        -: 4426: */
      147: 4427:static void maximize_sndbuf(const int sfd) {
      147: 4428:    socklen_t intsize = sizeof(int);
      147: 4429:    int last_good = 0;
        -: 4430:    int min, max, avg;
        -: 4431:    int old_size;
        -: 4432:
        -: 4433:    /* Start with the default size. */
      147: 4434:    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {
    #####: 4435:        if (settings.verbose > 0)
    #####: 4436:            perror("getsockopt(SO_SNDBUF)");
    #####: 4437:        return;
        -: 4438:    }
        -: 4439:
        -: 4440:    /* Binary-search for the real maximum. */
      147: 4441:    min = old_size;
      147: 4442:    max = MAX_SENDBUF_SIZE;
        -: 4443:
     4410: 4444:    while (min <= max) {
     4116: 4445:        avg = ((unsigned int)(min + max)) / 2;
     4116: 4446:        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {
     4116: 4447:            last_good = avg;
     4116: 4448:            min = avg + 1;
        -: 4449:        } else {
    #####: 4450:            max = avg - 1;
        -: 4451:        }
        -: 4452:    }
        -: 4453:
      147: 4454:    if (settings.verbose > 1)
        6: 4455:        fprintf(stderr, "<%d send buffer was %d, now %d\n", sfd, old_size, last_good);
        -: 4456:}
        -: 4457:
        -: 4458:/**
        -: 4459: * Create a socket and bind it to a specific port number
        -: 4460: * @param interface the interface to bind to
        -: 4461: * @param port the port number to bind to
        -: 4462: * @param transport the transport protocol (TCP / UDP)
        -: 4463: * @param portnumber_file A filepointer to write the port numbers to
        -: 4464: *        when they are successfully added to the list of ports we
        -: 4465: *        listen on.
        -: 4466: */
      153: 4467:static int server_socket(const char *interface,
        -: 4468:                         int port,
        -: 4469:                         enum network_transport transport,
        -: 4470:                         FILE *portnumber_file) {
        -: 4471:    int sfd;
      153: 4472:    struct linger ling = {0, 0};
        -: 4473:    struct addrinfo *ai;
      906: 4474:    struct addrinfo *next;
      153: 4475:    struct addrinfo hints = { .ai_flags = AI_PASSIVE,
        -: 4476:                              .ai_family = AF_UNSPEC };
        -: 4477:    char port_buf[NI_MAXSERV];
        -: 4478:    int error;
      153: 4479:    int success = 0;
      153: 4480:    int flags =1;
        -: 4481:
      153: 4482:    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;
        -: 4483:
      153: 4484:    if (port == -1) {
       10: 4485:        port = 0;
        -: 4486:    }
        -: 4487:    snprintf(port_buf, sizeof(port_buf), "%d", port);
      153: 4488:    error= getaddrinfo(interface, port_buf, &hints, &ai);
      153: 4489:    if (error != 0) {
        1: 4490:        if (error != EAI_SYSTEM)
        1: 4491:          fprintf(stderr, "getaddrinfo(): %s\n", gai_strerror(error));
        -: 4492:        else
    #####: 4493:          perror("getaddrinfo()");
        -: 4494:        return 1;
        -: 4495:    }
        -: 4496:
      454: 4497:    for (next= ai; next; next= next->ai_next) {
        -: 4498:        conn *listen_conn_add;
      906: 4499:        if ((sfd = new_socket(next)) == -1) {
        -: 4500:            /* getaddrinfo can return "junk" addresses,
        -: 4501:             * we make sure at least one works before erroring.
        -: 4502:             */
    #####: 4503:            if (errno == EMFILE) {
        -: 4504:                /* ...unless we're out of fds */
    #####: 4505:                perror("server_socket");
    #####: 4506:                exit(EX_OSERR);
        -: 4507:            }
    #####: 4508:            continue;
        -: 4509:        }
        -: 4510:
        -: 4511:#ifdef IPV6_V6ONLY
      302: 4512:        if (next->ai_family == AF_INET6) {
      150: 4513:            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));
      150: 4514:            if (error != 0) {
    #####: 4515:                perror("setsockopt");
    #####: 4516:                close(sfd);
    #####: 4517:                continue;
        -: 4518:            }
        -: 4519:        }
        -: 4520:#endif
        -: 4521:
      302: 4522:        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
      302: 4523:        if (IS_UDP(transport)) {
      147: 4524:            maximize_sndbuf(sfd);
        -: 4525:        } else {
      155: 4526:            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
      155: 4527:            if (error != 0)
    #####: 4528:                perror("setsockopt");
        -: 4529:
      155: 4530:            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
      155: 4531:            if (error != 0)
    #####: 4532:                perror("setsockopt");
        -: 4533:
      155: 4534:            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));
      155: 4535:            if (error != 0)
    #####: 4536:                perror("setsockopt");
        -: 4537:        }
        -: 4538:
      302: 4539:        if (bind(sfd, next->ai_addr, next->ai_addrlen) == -1) {
    #####: 4540:            if (errno != EADDRINUSE) {
    #####: 4541:                perror("bind()");
    #####: 4542:                close(sfd);
    #####: 4543:                freeaddrinfo(ai);
    #####: 4544:                return 1;
        -: 4545:            }
    #####: 4546:            close(sfd);
    #####: 4547:            continue;
        -: 4548:        } else {
      302: 4549:            success++;
      302: 4550:            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == -1) {
    #####: 4551:                perror("listen()");
    #####: 4552:                close(sfd);
    #####: 4553:                freeaddrinfo(ai);
    #####: 4554:                return 1;
        -: 4555:            }
      342: 4556:            if (portnumber_file != NULL &&
       40: 4557:                (next->ai_addr->sa_family == AF_INET ||
        -: 4558:                 next->ai_addr->sa_family == AF_INET6)) {
        -: 4559:                union {
        -: 4560:                    struct sockaddr_in in;
        -: 4561:                    struct sockaddr_in6 in6;
        -: 4562:                } my_sockaddr;
       40: 4563:                socklen_t len = sizeof(my_sockaddr);
       40: 4564:                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {
       40: 4565:                    if (next->ai_addr->sa_family == AF_INET) {
       20: 4566:                        fprintf(portnumber_file, "%s INET: %u\n",
        -: 4567:                                IS_UDP(transport) ? "UDP" : "TCP",
       20: 4568:                                ntohs(my_sockaddr.in.sin_port));
        -: 4569:                    } else {
       20: 4570:                        fprintf(portnumber_file, "%s INET6: %u\n",
        -: 4571:                                IS_UDP(transport) ? "UDP" : "TCP",
       20: 4572:                                ntohs(my_sockaddr.in6.sin6_port));
        -: 4573:                    }
        -: 4574:                }
        -: 4575:            }
        -: 4576:        }
        -: 4577:
      302: 4578:        if (IS_UDP(transport)) {
        -: 4579:            int c;
        -: 4580:
      588: 4581:            for (c = 0; c < settings.num_threads_per_udp; c++) {
        -: 4582:                /* Allocate one UDP file descriptor per worker thread;
        -: 4583:                 * this allows "stats conns" to separately list multiple
        -: 4584:                 * parallel UDP requests in progress.
        -: 4585:                 *
        -: 4586:                 * The dispatch code round-robins new connection requests
        -: 4587:                 * among threads, so this is guaranteed to assign one
        -: 4588:                 * FD to each thread.
        -: 4589:                 */
      588: 4590:                int per_thread_fd = c ? dup(sfd) : sfd;
      588: 4591:                dispatch_conn_new(per_thread_fd, conn_read,
        -: 4592:                                  EV_READ | EV_PERSIST,
        -: 4593:                                  UDP_READ_BUFFER_SIZE, transport);
        -: 4594:            }
        -: 4595:        } else {
      155: 4596:            if (!(listen_conn_add = conn_new(sfd, conn_listening,
        -: 4597:                                             EV_READ | EV_PERSIST, 1,
        -: 4598:                                             transport, main_base))) {
    #####: 4599:                fprintf(stderr, "failed to create listening connection\n");
    #####: 4600:                exit(EXIT_FAILURE);
        -: 4601:            }
      155: 4602:            listen_conn_add->next = listen_conn;
      155: 4603:            listen_conn = listen_conn_add;
        -: 4604:        }
        -: 4605:    }
        -: 4606:
      152: 4607:    freeaddrinfo(ai);
        -: 4608:
        -: 4609:    /* Return zero iff we detected no errors in starting up connections */
      152: 4610:    return success == 0;
        -: 4611:}
        -: 4612:
      153: 4613:static int server_sockets(int port, enum network_transport transport,
        -: 4614:                          FILE *portnumber_file) {
      153: 4615:    if (settings.inter == NULL) {
      150: 4616:        return server_socket(settings.inter, port, transport, portnumber_file);
        -: 4617:    } else {
        -: 4618:        // tokenize them and bind to each one of them..
        -: 4619:        char *b;
        3: 4620:        int ret = 0;
        3: 4621:        char *list = strdup(settings.inter);
        -: 4622:
        3: 4623:        if (list == NULL) {
    #####: 4624:            fprintf(stderr, "Failed to allocate memory for parsing server interface string\n");
    #####: 4625:            return 1;
        -: 4626:        }
        9: 4627:        for (char *p = strtok_r(list, ";,", &b);
        -: 4628:             p != NULL;
        3: 4629:             p = strtok_r(NULL, ";,", &b)) {
        3: 4630:            int the_port = port;
        -: 4631:
        3: 4632:            char *h = NULL;
        3: 4633:            if (*p == '[') {
        -: 4634:                // expecting it to be an IPv6 address enclosed in []
        -: 4635:                // i.e. RFC3986 style recommended by RFC5952
    #####: 4636:                char *e = strchr(p, ']');
    #####: 4637:                if (e == NULL) {
    #####: 4638:                    fprintf(stderr, "Invalid IPV6 address: \"%s\"", p);
    #####: 4639:                    return 1;
        -: 4640:                }
    #####: 4641:                h = ++p; // skip the opening '['
    #####: 4642:                *e = '\0';
    #####: 4643:                p = ++e; // skip the closing ']'
        -: 4644:            }
        -: 4645:
        3: 4646:            char *s = strchr(p, ':');
        3: 4647:            if (s != NULL) {
        -: 4648:                // If no more semicolons - attempt to treat as port number.
        -: 4649:                // Otherwise the only valid option is an unenclosed IPv6 without port, until
        -: 4650:                // of course there was an RFC3986 IPv6 address previously specified -
        -: 4651:                // in such a case there is no good option, will just send it to fail as port number.
    #####: 4652:                if (strchr(s + 1, ':') == NULL || h != NULL) {
    #####: 4653:                    *s = '\0';
    #####: 4654:                    ++s;
    #####: 4655:                    if (!safe_strtol(s, &the_port)) {
    #####: 4656:                        fprintf(stderr, "Invalid port number: \"%s\"", s);
    #####: 4657:                        return 1;
        -: 4658:                    }
        -: 4659:                }
        -: 4660:            }
        -: 4661:
        3: 4662:            if (h != NULL)
    #####: 4663:                p = h;
        -: 4664:
        3: 4665:            if (strcmp(p, "*") == 0) {
    #####: 4666:                p = NULL;
        -: 4667:            }
        3: 4668:            ret |= server_socket(p, the_port, transport, portnumber_file);
        -: 4669:        }
        3: 4670:        free(list);
        3: 4671:        return ret;
        -: 4672:    }
        -: 4673:}
        -: 4674:
        2: 4675:static int new_socket_unix(void) {
        -: 4676:    int sfd;
        -: 4677:    int flags;
        -: 4678:
        2: 4679:    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
    #####: 4680:        perror("socket()");
    #####: 4681:        return -1;
        -: 4682:    }
        -: 4683:
        4: 4684:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
        2: 4685:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 4686:        perror("setting O_NONBLOCK");
    #####: 4687:        close(sfd);
    #####: 4688:        return -1;
        -: 4689:    }
        -: 4690:    return sfd;
        -: 4691:}
        -: 4692:
        2: 4693:static int server_socket_unix(const char *path, int access_mask) {
        -: 4694:    int sfd;
        2: 4695:    struct linger ling = {0, 0};
        -: 4696:    struct sockaddr_un addr;
        -: 4697:    struct stat tstat;
        2: 4698:    int flags =1;
        -: 4699:    int old_umask;
        -: 4700:
        2: 4701:    if (!path) {
        -: 4702:        return 1;
        -: 4703:    }
        -: 4704:
        2: 4705:    if ((sfd = new_socket_unix()) == -1) {
        -: 4706:        return 1;
        -: 4707:    }
        -: 4708:
        -: 4709:    /*
        -: 4710:     * Clean up a previous socket file if we left it around
        -: 4711:     */
        2: 4712:    if (lstat(path, &tstat) == 0) {
    #####: 4713:        if (S_ISSOCK(tstat.st_mode))
    #####: 4714:            unlink(path);
        -: 4715:    }
        -: 4716:
        2: 4717:    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
        2: 4718:    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
        2: 4719:    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
        -: 4720:
        -: 4721:    /*
        -: 4722:     * the memset call clears nonstandard fields in some impementations
        -: 4723:     * that otherwise mess things up.
        -: 4724:     */
        -: 4725:    memset(&addr, 0, sizeof(addr));
        -: 4726:
        2: 4727:    addr.sun_family = AF_UNIX;
        -: 4728:    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
        2: 4729:    assert(strcmp(addr.sun_path, path) == 0);
        2: 4730:    old_umask = umask( ~(access_mask&0777));
        2: 4731:    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
    #####: 4732:        perror("bind()");
    #####: 4733:        close(sfd);
    #####: 4734:        umask(old_umask);
    #####: 4735:        return 1;
        -: 4736:    }
        2: 4737:    umask(old_umask);
        2: 4738:    if (listen(sfd, settings.backlog) == -1) {
    #####: 4739:        perror("listen()");
    #####: 4740:        close(sfd);
    #####: 4741:        return 1;
        -: 4742:    }
        2: 4743:    if (!(listen_conn = conn_new(sfd, conn_listening,
        -: 4744:                                 EV_READ | EV_PERSIST, 1,
        -: 4745:                                 local_transport, main_base))) {
    #####: 4746:        fprintf(stderr, "failed to create listening connection\n");
    #####: 4747:        exit(EXIT_FAILURE);
        -: 4748:    }
        -: 4749:
        -: 4750:    return 0;
        -: 4751:}
        -: 4752:
        -: 4753:/*
        -: 4754: * We keep the current time of day in a global variable that's updated by a
        -: 4755: * timer event. This saves us a bunch of time() system calls (we really only
        -: 4756: * need to get the time once a second, whereas there can be tens of thousands
        -: 4757: * of requests a second) and allows us to use server-start-relative timestamps
        -: 4758: * rather than absolute UNIX timestamps, a space savings on systems where
        -: 4759: * sizeof(time_t) > sizeof(unsigned int).
        -: 4760: */
        -: 4761:volatile rel_time_t current_time;
        -: 4762:static struct event clockevent;
        -: 4763:
        -: 4764:/* libevent uses a monotonic clock when available for event scheduling. Aside
        -: 4765: * from jitter, simply ticking our internal timer here is accurate enough.
        -: 4766: * Note that users who are setting explicit dates for expiration times *must*
        -: 4767: * ensure their clocks are correct before starting memcached. */
      216: 4768:static void clock_handler(const int fd, const short which, void *arg) {
      216: 4769:    struct timeval t = {.tv_sec = 1, .tv_usec = 0};
        -: 4770:    static bool initialized = false;
        -: 4771:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        -: 4772:    static bool monotonic = false;
        -: 4773:    static time_t monotonic_start;
        -: 4774:#endif
        -: 4775:
      216: 4776:    if (initialized) {
        -: 4777:        /* only delete the event if it's actually there. */
      133: 4778:        evtimer_del(&clockevent);
        -: 4779:    } else {
       83: 4780:        initialized = true;
        -: 4781:        /* process_started is initialized to time() - 2. We initialize to 1 so
        -: 4782:         * flush_all won't underflow during tests. */
        -: 4783:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        -: 4784:        struct timespec ts;
       83: 4785:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0) {
       83: 4786:            monotonic = true;
       83: 4787:            monotonic_start = ts.tv_sec - ITEM_UPDATE_INTERVAL - 2;
        -: 4788:        }
        -: 4789:#endif
        -: 4790:    }
        -: 4791:
      216: 4792:    evtimer_set(&clockevent, clock_handler, 0);
      216: 4793:    event_base_set(main_base, &clockevent);
      216: 4794:    evtimer_add(&clockevent, &t);
        -: 4795:
        -: 4796:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
      216: 4797:    if (monotonic) {
        -: 4798:        struct timespec ts;
      216: 4799:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
        -: 4800:            return;
      216: 4801:        current_time = (rel_time_t) (ts.tv_sec - monotonic_start);
      216: 4802:        return;
        -: 4803:    }
        -: 4804:#endif
        -: 4805:    {
        -: 4806:        struct timeval tv;
    #####: 4807:        gettimeofday(&tv, NULL);
    #####: 4808:        current_time = (rel_time_t) (tv.tv_sec - process_started);
        -: 4809:    }
        -: 4810:}
        -: 4811:
       77: 4812:static void usage(void) {
        -: 4813:    printf(PACKAGE " " VERSION "\n");
        -: 4814:    printf("-p <num>      TCP port number to listen on (default: 11211)\n"
        -: 4815:           "-U <num>      UDP port number to listen on (default: 11211, 0 is off)\n"
        -: 4816:           "-s <file>     UNIX socket path to listen on (disables network support)\n"
        -: 4817:           "-A            enable ascii \"shutdown\" command\n"
        -: 4818:           "-a <mask>     access mask for UNIX socket, in octal (default: 0700)\n"
        -: 4819:           "-l <addr>     interface to listen on (default: INADDR_ANY, all addresses)\n"
        -: 4820:           "              <addr> may be specified as host:port. If you don't specify\n"
        -: 4821:           "              a port number, the value you specified with -p or -U is\n"
        -: 4822:           "              used. You may specify multiple addresses separated by comma\n"
        -: 4823:           "              or by using -l multiple times\n"
        -: 4824:
        -: 4825:           "-d            run as a daemon\n"
        -: 4826:           "-r            maximize core file limit\n"
        -: 4827:           "-u <username> assume identity of <username> (only when run as root)\n"
        -: 4828:           "-m <num>      max memory to use for items in megabytes (default: 64 MB)\n"
        -: 4829:           "-M            return error on memory exhausted (rather than removing items)\n"
        -: 4830:           "-c <num>      max simultaneous connections (default: 1024)\n"
        -: 4831:           "-k            lock down all paged memory.  Note that there is a\n"
        -: 4832:           "              limit on how much memory you may lock.  Trying to\n"
        -: 4833:           "              allocate more than that would fail, so be sure you\n"
        -: 4834:           "              set the limit correctly for the user you started\n"
        -: 4835:           "              the daemon with (not for -u <username> user;\n"
        -: 4836:           "              under sh this is done with 'ulimit -S -l NUM_KB').\n"
        -: 4837:           "-v            verbose (print errors/warnings while in event loop)\n"
        -: 4838:           "-vv           very verbose (also print client commands/reponses)\n"
        -: 4839:           "-vvv          extremely verbose (also print internal state transitions)\n"
        -: 4840:           "-h            print this help and exit\n"
        -: 4841:           "-i            print memcached and libevent license\n"
        -: 4842:           "-V            print version and exit\n"
        -: 4843:           "-P <file>     save PID in <file>, only used with -d option\n"
        -: 4844:           "-f <factor>   chunk size growth factor (default: 1.25)\n"
        -: 4845:           "-n <bytes>    minimum space allocated for key+value+flags (default: 48)\n");
        -: 4846:    printf("-L            Try to use large memory pages (if available). Increasing\n"
        -: 4847:           "              the memory page size could reduce the number of TLB misses\n"
        -: 4848:           "              and improve the performance. In order to get large pages\n"
        -: 4849:           "              from the OS, memcached will allocate the total item-cache\n"
        -: 4850:           "              in one large chunk.\n");
        -: 4851:    printf("-D <char>     Use <char> as the delimiter between key prefixes and IDs.\n"
        -: 4852:           "              This is used for per-prefix stats reporting. The default is\n"
        -: 4853:           "              \":\" (colon). If this option is specified, stats collection\n"
        -: 4854:           "              is turned on automatically; if not, then it may be turned on\n"
        -: 4855:           "              by sending the \"stats detail on\" command to the server.\n");
        -: 4856:    printf("-t <num>      number of threads to use (default: 4)\n");
        -: 4857:    printf("-R            Maximum number of requests per event, limits the number of\n"
        -: 4858:           "              requests process for a given connection to prevent \n"
        -: 4859:           "              starvation (default: 20)\n");
        -: 4860:    printf("-C            Disable use of CAS\n");
        -: 4861:    printf("-b <num>      Set the backlog queue limit (default: 1024)\n");
        -: 4862:    printf("-B            Binding protocol - one of ascii, binary, or auto (default)\n");
        -: 4863:    printf("-I            Override the size of each slab page. Adjusts max item size\n"
        -: 4864:           "              (default: 1mb, min: 1k, max: 128m)\n");
        -: 4865:#ifdef ENABLE_SASL
        -: 4866:    printf("-S            Turn on Sasl authentication\n");
        -: 4867:#endif
        -: 4868:    printf("-F            Disable flush_all command\n");
        -: 4869:    printf("-o            Comma separated list of extended or experimental options\n"
        -: 4870:           "              - (EXPERIMENTAL) maxconns_fast: immediately close new\n"
        -: 4871:           "                connections if over maxconns limit\n"
        -: 4872:           "              - hashpower: An integer multiplier for how large the hash\n"
        -: 4873:           "                table should be. Can be grown at runtime if not big enough.\n"
        -: 4874:           "                Set this based on \"STAT hash_power_level\" before a \n"
        -: 4875:           "                restart.\n"
        -: 4876:           "              - tail_repair_time: Time in seconds that indicates how long to wait before\n"
        -: 4877:           "                forcefully taking over the LRU tail item whose refcount has leaked.\n"
        -: 4878:           "                Disabled by default; dangerous option.\n"
        -: 4879:           "              - hash_algorithm: The hash table algorithm\n"
        -: 4880:           "                default is jenkins hash. options: jenkins, murmur3\n"
        -: 4881:           "              - lru_crawler: Enable LRU Crawler background thread\n"
        -: 4882:           "              - lru_crawler_sleep: Microseconds to sleep between items\n"
        -: 4883:           "                default is 100.\n"
        -: 4884:           "              - lru_crawler_tocrawl: Max items to crawl per slab per run\n"
        -: 4885:           "                default is 0 (unlimited)\n"
        -: 4886:           "              - lru_maintainer: Enable new LRU system + background thread\n"
        -: 4887:           "              - hot_lru_pct: Pct of slab memory to reserve for hot lru.\n"
        -: 4888:           "                (requires lru_maintainer)\n"
        -: 4889:           "              - warm_lru_pct: Pct of slab memory to reserve for warm lru.\n"
        -: 4890:           "                (requires lru_maintainer)\n"
        -: 4891:           "              - expirezero_does_not_evict: Items set to not expire, will not evict.\n"
        -: 4892:           "                (requires lru_maintainer)\n"
        -: 4893:           );
       77: 4894:    return;
        -: 4895:}
        -: 4896:
    #####: 4897:static void usage_license(void) {
        -: 4898:    printf(PACKAGE " " VERSION "\n\n");
        -: 4899:    printf(
        -: 4900:    "Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\n"
        -: 4901:    "All rights reserved.\n"
        -: 4902:    "\n"
        -: 4903:    "Redistribution and use in source and binary forms, with or without\n"
        -: 4904:    "modification, are permitted provided that the following conditions are\n"
        -: 4905:    "met:\n"
        -: 4906:    "\n"
        -: 4907:    "    * Redistributions of source code must retain the above copyright\n"
        -: 4908:    "notice, this list of conditions and the following disclaimer.\n"
        -: 4909:    "\n"
        -: 4910:    "    * Redistributions in binary form must reproduce the above\n"
        -: 4911:    "copyright notice, this list of conditions and the following disclaimer\n"
        -: 4912:    "in the documentation and/or other materials provided with the\n"
        -: 4913:    "distribution.\n"
        -: 4914:    "\n"
        -: 4915:    "    * Neither the name of the Danga Interactive nor the names of its\n"
        -: 4916:    "contributors may be used to endorse or promote products derived from\n"
        -: 4917:    "this software without specific prior written permission.\n"
        -: 4918:    "\n"
        -: 4919:    "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
        -: 4920:    "\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
        -: 4921:    "LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n"
        -: 4922:    "A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n"
        -: 4923:    "OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n"
        -: 4924:    "SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n"
        -: 4925:    "LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
        -: 4926:    "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
        -: 4927:    "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
        -: 4928:    "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
        -: 4929:    "OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        -: 4930:    "\n"
        -: 4931:    "\n"
        -: 4932:    "This product includes software developed by Niels Provos.\n"
        -: 4933:    "\n"
        -: 4934:    "[ libevent ]\n"
        -: 4935:    "\n"
        -: 4936:    "Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\n"
        -: 4937:    "All rights reserved.\n"
        -: 4938:    "\n"
        -: 4939:    "Redistribution and use in source and binary forms, with or without\n"
        -: 4940:    "modification, are permitted provided that the following conditions\n"
        -: 4941:    "are met:\n"
        -: 4942:    "1. Redistributions of source code must retain the above copyright\n"
        -: 4943:    "   notice, this list of conditions and the following disclaimer.\n"
        -: 4944:    "2. Redistributions in binary form must reproduce the above copyright\n"
        -: 4945:    "   notice, this list of conditions and the following disclaimer in the\n"
        -: 4946:    "   documentation and/or other materials provided with the distribution.\n"
        -: 4947:    "3. All advertising materials mentioning features or use of this software\n"
        -: 4948:    "   must display the following acknowledgement:\n"
        -: 4949:    "      This product includes software developed by Niels Provos.\n"
        -: 4950:    "4. The name of the author may not be used to endorse or promote products\n"
        -: 4951:    "   derived from this software without specific prior written permission.\n"
        -: 4952:    "\n"
        -: 4953:    "THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n"
        -: 4954:    "IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n"
        -: 4955:    "OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n"
        -: 4956:    "IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
        -: 4957:    "INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n"
        -: 4958:    "NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
        -: 4959:    "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
        -: 4960:    "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
        -: 4961:    "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n"
        -: 4962:    "THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        -: 4963:    );
        -: 4964:
    #####: 4965:    return;
        -: 4966:}
        -: 4967:
        1: 4968:static void save_pid(const char *pid_file) {
        -: 4969:    FILE *fp;
        1: 4970:    if (access(pid_file, F_OK) == 0) {
    #####: 4971:        if ((fp = fopen(pid_file, "r")) != NULL) {
        -: 4972:            char buffer[1024];
    #####: 4973:            if (fgets(buffer, sizeof(buffer), fp) != NULL) {
        -: 4974:                unsigned int pid;
    #####: 4975:                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
    #####: 4976:                    fprintf(stderr, "WARNING: The pid file contained the following (running) pid: %u\n", pid);
        -: 4977:                }
        -: 4978:            }
    #####: 4979:            fclose(fp);
        -: 4980:        }
        -: 4981:    }
        -: 4982:
        -: 4983:    /* Create the pid file first with a temporary name, then
        -: 4984:     * atomically move the file to the real name to avoid a race with
        -: 4985:     * another process opening the file to read the pid, but finding
        -: 4986:     * it empty.
        -: 4987:     */
        -: 4988:    char tmp_pid_file[1024];
        -: 4989:    snprintf(tmp_pid_file, sizeof(tmp_pid_file), "%s.tmp", pid_file);
        -: 4990:
        1: 4991:    if ((fp = fopen(tmp_pid_file, "w")) == NULL) {
    #####: 4992:        vperror("Could not open the pid file %s for writing", tmp_pid_file);
        1: 4993:        return;
        -: 4994:    }
        -: 4995:
        1: 4996:    fprintf(fp,"%ld\n", (long)getpid());
        1: 4997:    if (fclose(fp) == -1) {
    #####: 4998:        vperror("Could not close the pid file %s", tmp_pid_file);
        -: 4999:    }
        -: 5000:
        1: 5001:    if (rename(tmp_pid_file, pid_file) != 0) {
    #####: 5002:        vperror("Could not rename the pid file from %s to %s",
        -: 5003:                tmp_pid_file, pid_file);
        -: 5004:    }
        -: 5005:}
        -: 5006:
    #####: 5007:static void remove_pidfile(const char *pid_file) {
    #####: 5008:  if (pid_file == NULL)
    #####: 5009:      return;
        -: 5010:
    #####: 5011:  if (unlink(pid_file) != 0) {
    #####: 5012:      vperror("Could not remove the pid file %s", pid_file);
        -: 5013:  }
        -: 5014:
        -: 5015:}
        -: 5016:
       82: 5017:static void sig_handler(const int sig) {
       82: 5018:    printf("Signal handled: %s.\n", strsignal(sig));
       82: 5019:    exit(EXIT_SUCCESS);
        -: 5020:}
        -: 5021:
        -: 5022:#ifndef HAVE_SIGIGNORE
        -: 5023:static int sigignore(int sig) {
        -: 5024:    struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };
        -: 5025:
        -: 5026:    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {
        -: 5027:        return -1;
        -: 5028:    }
        -: 5029:    return 0;
        -: 5030:}
        -: 5031:#endif
        -: 5032:
        -: 5033:
        -: 5034:/*
        -: 5035: * On systems that supports multiple page sizes we may reduce the
        -: 5036: * number of TLB-misses by using the biggest available page size
        -: 5037: */
        -: 5038:static int enable_large_pages(void) {
        -: 5039:#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)
        -: 5040:    int ret = -1;
        -: 5041:    size_t sizes[32];
        -: 5042:    int avail = getpagesizes(sizes, 32);
        -: 5043:    if (avail != -1) {
        -: 5044:        size_t max = sizes[0];
        -: 5045:        struct memcntl_mha arg = {0};
        -: 5046:        int ii;
        -: 5047:
        -: 5048:        for (ii = 1; ii < avail; ++ii) {
        -: 5049:            if (max < sizes[ii]) {
        -: 5050:                max = sizes[ii];
        -: 5051:            }
        -: 5052:        }
        -: 5053:
        -: 5054:        arg.mha_flags   = 0;
        -: 5055:        arg.mha_pagesize = max;
        -: 5056:        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;
        -: 5057:
        -: 5058:        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {
        -: 5059:            fprintf(stderr, "Failed to set large pages: %s\n",
        -: 5060:                    strerror(errno));
        -: 5061:            fprintf(stderr, "Will use default page size\n");
        -: 5062:        } else {
        -: 5063:            ret = 0;
        -: 5064:        }
        -: 5065:    } else {
        -: 5066:        fprintf(stderr, "Failed to get supported pagesizes: %s\n",
        -: 5067:                strerror(errno));
        -: 5068:        fprintf(stderr, "Will use default page size\n");
        -: 5069:    }
        -: 5070:
        -: 5071:    return ret;
        -: 5072:#else
        -: 5073:    return -1;
        -: 5074:#endif
        -: 5075:}
        -: 5076:
        -: 5077:/**
        -: 5078: * Do basic sanity check of the runtime environment
        -: 5079: * @return true if no errors found, false if we can't use this env
        -: 5080: */
      166: 5081:static bool sanitycheck(void) {
        -: 5082:    /* One of our biggest problems is old and bogus libevents */
      166: 5083:    const char *ever = event_get_version();
      166: 5084:    if (ever != NULL) {
      166: 5085:        if (strncmp(ever, "1.", 2) == 0) {
        -: 5086:            /* Require at least 1.3 (that's still a couple of years old) */
    #####: 5087:            if (('0' <= ever[2] && ever[2] < '3') && !isdigit(ever[3])) {
    #####: 5088:                fprintf(stderr, "You are using libevent %s.\nPlease upgrade to"
        -: 5089:                        " a more recent version (1.3 or newer)\n",
        -: 5090:                        event_get_version());
    #####: 5091:                return false;
        -: 5092:            }
        -: 5093:        }
        -: 5094:    }
        -: 5095:
        -: 5096:    return true;
        -: 5097:}
        -: 5098:
      166: 5099:int main (int argc, char **argv) {
        -: 5100:    int c;
      166: 5101:    bool lock_memory = false;
      166: 5102:    bool do_daemonize = false;
      166: 5103:    bool preallocate = false;
      166: 5104:    int maxcore = 0;
      166: 5105:    char *username = NULL;
      166: 5106:    char *pid_file = NULL;
        -: 5107:    struct passwd *pw;
        -: 5108:    struct rlimit rlim;
        -: 5109:    char *buf;
      166: 5110:    char unit = '\0';
      166: 5111:    int size_max = 0;
      166: 5112:    int retval = EXIT_SUCCESS;
        -: 5113:    /* listening sockets */
        -: 5114:    static int *l_socket = NULL;
        -: 5115:
        -: 5116:    /* udp socket */
        -: 5117:    static int *u_socket = NULL;
      166: 5118:    bool protocol_specified = false;
      166: 5119:    bool tcp_specified = false;
      166: 5120:    bool udp_specified = false;
      166: 5121:    bool start_lru_maintainer = false;
      166: 5122:    bool start_lru_crawler = false;
      166: 5123:    enum hashfunc_type hash_type = JENKINS_HASH;
        -: 5124:    uint32_t tocrawl;
        -: 5125:
        -: 5126:    char *subopts, *subopts_orig;
        -: 5127:    char *subopts_value;
        -: 5128:    enum {
        -: 5129:        MAXCONNS_FAST = 0,
        -: 5130:        HASHPOWER_INIT,
        -: 5131:        SLAB_REASSIGN,
        -: 5132:        SLAB_AUTOMOVE,
        -: 5133:        TAIL_REPAIR_TIME,
        -: 5134:        HASH_ALGORITHM,
        -: 5135:        LRU_CRAWLER,
        -: 5136:        LRU_CRAWLER_SLEEP,
        -: 5137:        LRU_CRAWLER_TOCRAWL,
        -: 5138:        LRU_MAINTAINER,
        -: 5139:        HOT_LRU_PCT,
        -: 5140:        WARM_LRU_PCT,
        -: 5141:        NOEXP_NOEVICT
        -: 5142:    };
      166: 5143:    char *const subopts_tokens[] = {
        -: 5144:        [MAXCONNS_FAST] = "maxconns_fast",
        -: 5145:        [HASHPOWER_INIT] = "hashpower",
        -: 5146:        [SLAB_REASSIGN] = "slab_reassign",
        -: 5147:        [SLAB_AUTOMOVE] = "slab_automove",
        -: 5148:        [TAIL_REPAIR_TIME] = "tail_repair_time",
        -: 5149:        [HASH_ALGORITHM] = "hash_algorithm",
        -: 5150:        [LRU_CRAWLER] = "lru_crawler",
        -: 5151:        [LRU_CRAWLER_SLEEP] = "lru_crawler_sleep",
        -: 5152:        [LRU_CRAWLER_TOCRAWL] = "lru_crawler_tocrawl",
        -: 5153:        [LRU_MAINTAINER] = "lru_maintainer",
        -: 5154:        [HOT_LRU_PCT] = "hot_lru_pct",
        -: 5155:        [WARM_LRU_PCT] = "warm_lru_pct",
        -: 5156:        [NOEXP_NOEVICT] = "expirezero_does_not_evict",
        -: 5157:        NULL
        -: 5158:    };
        -: 5159:
      166: 5160:    if (!sanitycheck()) {
        -: 5161:        return EX_OSERR;
        -: 5162:    }
        -: 5163:
        -: 5164:    /* handle SIGINT and SIGTERM */
      166: 5165:    signal(SIGINT, sig_handler);
      166: 5166:    signal(SIGTERM, sig_handler);
        -: 5167:
        -: 5168:    /* init settings */
      166: 5169:    settings_init();
        -: 5170:
        -: 5171:    /* Run regardless of initializing it later */
      166: 5172:    init_lru_crawler();
      166: 5173:    init_lru_maintainer();
        -: 5174:
        -: 5175:    /* set stderr non-buffering (for running under, say, daemontools) */
      166: 5176:    setbuf(stderr, NULL);
        -: 5177:
        -: 5178:    /* process arguments */
      546: 5179:    while (-1 != (c = getopt(argc, argv,
        -: 5180:          "a:"  /* access mask for unix socket */
        -: 5181:          "A"  /* enable admin shutdown commannd */
        -: 5182:          "p:"  /* TCP port number to listen on */
        -: 5183:          "s:"  /* unix socket path to listen on */
        -: 5184:          "U:"  /* UDP port number to listen on */
        -: 5185:          "m:"  /* max memory to use for items in megabytes */
        -: 5186:          "M"   /* return error on memory exhausted */
        -: 5187:          "c:"  /* max simultaneous connections */
        -: 5188:          "k"   /* lock down all paged memory */
        -: 5189:          "hiV" /* help, licence info, version */
        -: 5190:          "r"   /* maximize core file limit */
        -: 5191:          "v"   /* verbose */
        -: 5192:          "d"   /* daemon mode */
        -: 5193:          "l:"  /* interface to listen on */
        -: 5194:          "u:"  /* user identity to run as */
        -: 5195:          "P:"  /* save PID in file */
        -: 5196:          "f:"  /* factor? */
        -: 5197:          "n:"  /* minimum space allocated for key+value+flags */
        -: 5198:          "t:"  /* threads */
        -: 5199:          "D:"  /* prefix delimiter? */
        -: 5200:          "L"   /* Large memory pages */
        -: 5201:          "R:"  /* max requests per event */
        -: 5202:          "C"   /* Disable use of CAS */
        -: 5203:          "b:"  /* backlog queue limit */
        -: 5204:          "B:"  /* Binding protocol */
        -: 5205:          "I:"  /* Max item size */
        -: 5206:          "S"   /* Sasl ON */
        -: 5207:          "F"   /* Disable flush_all */
        -: 5208:          "o:"  /* Extended generic options */
        -: 5209:        ))) {
      296: 5210:        switch (c) {
        -: 5211:        case 'A':
        -: 5212:            /* enables "shutdown" command */
        3: 5213:            settings.shutdown_command = true;
        3: 5214:            break;
        -: 5215:
        -: 5216:        case 'a':
        -: 5217:            /* access for unix domain socket, as octal mask (like chmod)*/
    #####: 5218:            settings.access= strtol(optarg,NULL,8);
    #####: 5219:            break;
        -: 5220:
        -: 5221:        case 'U':
      162: 5222:            settings.udpport = atoi(optarg);
       81: 5223:            udp_specified = true;
       81: 5224:            break;
        -: 5225:        case 'p':
      162: 5226:            settings.port = atoi(optarg);
       81: 5227:            tcp_specified = true;
       81: 5228:            break;
        -: 5229:        case 's':
        2: 5230:            settings.socketpath = optarg;
        2: 5231:            break;
        -: 5232:        case 'm':
       22: 5233:            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;
       11: 5234:            break;
        -: 5235:        case 'M':
        2: 5236:            settings.evict_to_free = 0;
        2: 5237:            break;
        -: 5238:        case 'c':
        2: 5239:            settings.maxconns = atoi(optarg);
        1: 5240:            break;
        -: 5241:        case 'h':
       77: 5242:            usage();
       77: 5243:            exit(EXIT_SUCCESS);
        -: 5244:        case 'i':
    #####: 5245:            usage_license();
    #####: 5246:            exit(EXIT_SUCCESS);
        -: 5247:        case 'V':
        -: 5248:            printf(PACKAGE " " VERSION "\n");
    #####: 5249:            exit(EXIT_SUCCESS);
        -: 5250:        case 'k':
        -: 5251:            lock_memory = true;
        -: 5252:            break;
        -: 5253:        case 'v':
        6: 5254:            settings.verbose++;
        6: 5255:            break;
        -: 5256:        case 'l':
        2: 5257:            if (settings.inter != NULL) {
    #####: 5258:                if (strstr(settings.inter, optarg) != NULL) {
        -: 5259:                    break;
        -: 5260:                }
    #####: 5261:                size_t len = strlen(settings.inter) + strlen(optarg) + 2;
    #####: 5262:                char *p = malloc(len);
    #####: 5263:                if (p == NULL) {
    #####: 5264:                    fprintf(stderr, "Failed to allocate memory\n");
    #####: 5265:                    return 1;
        -: 5266:                }
    #####: 5267:                snprintf(p, len, "%s,%s", settings.inter, optarg);
    #####: 5268:                free(settings.inter);
    #####: 5269:                settings.inter = p;
        -: 5270:            } else {
        2: 5271:                settings.inter= strdup(optarg);
        -: 5272:            }
        -: 5273:            break;
        -: 5274:        case 'd':
        2: 5275:            do_daemonize = true;
        2: 5276:            break;
        -: 5277:        case 'r':
    #####: 5278:            maxcore = 1;
    #####: 5279:            break;
        -: 5280:        case 'R':
        2: 5281:            settings.reqs_per_event = atoi(optarg);
        1: 5282:            if (settings.reqs_per_event == 0) {
    #####: 5283:                fprintf(stderr, "Number of requests per event must be greater than 0\n");
    #####: 5284:                return 1;
        -: 5285:            }
        -: 5286:            break;
        -: 5287:        case 'u':
    #####: 5288:            username = optarg;
    #####: 5289:            break;
        -: 5290:        case 'P':
        2: 5291:            pid_file = optarg;
        2: 5292:            break;
        -: 5293:        case 'f':
    #####: 5294:            settings.factor = atof(optarg);
    #####: 5295:            if (settings.factor <= 1.0) {
    #####: 5296:                fprintf(stderr, "Factor must be greater than 1\n");
    #####: 5297:                return 1;
        -: 5298:            }
        -: 5299:            break;
        -: 5300:        case 'n':
    #####: 5301:            settings.chunk_size = atoi(optarg);
    #####: 5302:            if (settings.chunk_size == 0) {
    #####: 5303:                fprintf(stderr, "Chunk size must be greater than 0\n");
    #####: 5304:                return 1;
        -: 5305:            }
        -: 5306:            break;
        -: 5307:        case 't':
        2: 5308:            settings.num_threads = atoi(optarg);
        1: 5309:            if (settings.num_threads <= 0) {
        1: 5310:                fprintf(stderr, "Number of threads must be greater than 0\n");
        1: 5311:                return 1;
        -: 5312:            }
        -: 5313:            /* There're other problems when you get above 64 threads.
        -: 5314:             * In the future we should portably detect # of cores for the
        -: 5315:             * default.
        -: 5316:             */
    #####: 5317:            if (settings.num_threads > 64) {
    #####: 5318:                fprintf(stderr, "WARNING: Setting a high number of worker"
        -: 5319:                                "threads is not recommended.\n"
        -: 5320:                                " Set this value to the number of cores in"
        -: 5321:                                " your machine or less.\n");
        -: 5322:            }
        -: 5323:            break;
        -: 5324:        case 'D':
    #####: 5325:            if (! optarg || ! optarg[0]) {
    #####: 5326:                fprintf(stderr, "No delimiter specified\n");
    #####: 5327:                return 1;
        -: 5328:            }
    #####: 5329:            settings.prefix_delimiter = optarg[0];
    #####: 5330:            settings.detail_enabled = 1;
    #####: 5331:            break;
        -: 5332:        case 'L' :
        -: 5333:            if (enable_large_pages() == 0) {
        -: 5334:                preallocate = true;
        -: 5335:            } else {
    #####: 5336:                fprintf(stderr, "Cannot enable large pages on this system\n"
        -: 5337:                    "(There is no Linux support as of this version)\n");
    #####: 5338:                return 1;
        -: 5339:            }
        -: 5340:            break;
        -: 5341:        case 'C' :
        2: 5342:            settings.use_cas = false;
        2: 5343:            break;
        -: 5344:        case 'b' :
        2: 5345:            settings.backlog = atoi(optarg);
        1: 5346:            break;
        -: 5347:        case 'B':
        8: 5348:            protocol_specified = true;
        8: 5349:            if (strcmp(optarg, "auto") == 0) {
        2: 5350:                settings.binding_protocol = negotiating_prot;
        6: 5351:            } else if (strcmp(optarg, "binary") == 0) {
        3: 5352:                settings.binding_protocol = binary_prot;
        3: 5353:            } else if (strcmp(optarg, "ascii") == 0) {
        2: 5354:                settings.binding_protocol = ascii_prot;
        -: 5355:            } else {
        1: 5356:                fprintf(stderr, "Invalid value for binding protocol: %s\n"
        -: 5357:                        " -- should be one of auto, binary, or ascii\n", optarg);
        1: 5358:                exit(EX_USAGE);
        -: 5359:            }
        -: 5360:            break;
        -: 5361:        case 'I':
        6: 5362:            buf = strdup(optarg);
        6: 5363:            unit = buf[strlen(buf)-1];
        6: 5364:            if (unit == 'k' || unit == 'm' ||
        3: 5365:                unit == 'K' || unit == 'M') {
        3: 5366:                buf[strlen(buf)-1] = '\0';
        3: 5367:                size_max = atoi(buf);
        3: 5368:                if (unit == 'k' || unit == 'K')
        1: 5369:                    size_max *= 1024;
        3: 5370:                if (unit == 'm' || unit == 'M')
        2: 5371:                    size_max *= 1024 * 1024;
        3: 5372:                settings.item_size_max = size_max;
        -: 5373:            } else {
        3: 5374:                settings.item_size_max = atoi(buf);
        -: 5375:            }
        6: 5376:            free(buf);
        6: 5377:            if (settings.item_size_max < 1024) {
        1: 5378:                fprintf(stderr, "Item max size cannot be less than 1024 bytes.\n");
        1: 5379:                return 1;
        -: 5380:            }
        5: 5381:            if (settings.item_size_max > 1024 * 1024 * 128) {
        1: 5382:                fprintf(stderr, "Cannot set item size limit higher than 128 mb.\n");
        1: 5383:                return 1;
        -: 5384:            }
        4: 5385:            if (settings.item_size_max > 1024 * 1024) {
        2: 5386:                fprintf(stderr, "WARNING: Setting item max size above 1MB is not"
        -: 5387:                    " recommended!\n"
        -: 5388:                    " Raising this limit increases the minimum memory requirements\n"
        -: 5389:                    " and will decrease your memory efficiency.\n"
        -: 5390:                );
        -: 5391:            }
        -: 5392:            break;
        -: 5393:        case 'S': /* set Sasl authentication to true. Default is false */
        -: 5394:#ifndef ENABLE_SASL
        1: 5395:            fprintf(stderr, "This server is not built with SASL support.\n");
        1: 5396:            exit(EX_USAGE);
        -: 5397:#endif
        -: 5398:            settings.sasl = true;
        -: 5399:            break;
        -: 5400:       case 'F' :
        1: 5401:            settings.flush_enabled = false;
        1: 5402:            break;
        -: 5403:        case 'o': /* It's sub-opts time! */
        5: 5404:            subopts_orig = subopts = strdup(optarg); /* getsubopt() changes the original args */
        -: 5405:
       21: 5406:            while (*subopts != '\0') {
        -: 5407:
       11: 5408:            switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {
        -: 5409:            case MAXCONNS_FAST:
    #####: 5410:                settings.maxconns_fast = true;
    #####: 5411:                break;
        -: 5412:            case HASHPOWER_INIT:
    #####: 5413:                if (subopts_value == NULL) {
    #####: 5414:                    fprintf(stderr, "Missing numeric argument for hashpower\n");
    #####: 5415:                    return 1;
        -: 5416:                }
    #####: 5417:                settings.hashpower_init = atoi(subopts_value);
    #####: 5418:                if (settings.hashpower_init < 12) {
    #####: 5419:                    fprintf(stderr, "Initial hashtable multiplier of %d is too low\n",
        -: 5420:                        settings.hashpower_init);
    #####: 5421:                    return 1;
    #####: 5422:                } else if (settings.hashpower_init > 64) {
    #####: 5423:                    fprintf(stderr, "Initial hashtable multiplier of %d is too high\n"
        -: 5424:                        "Choose a value based on \"STAT hash_power_level\" from a running instance\n",
        -: 5425:                        settings.hashpower_init);
    #####: 5426:                    return 1;
        -: 5427:                }
        -: 5428:                break;
        -: 5429:            case SLAB_REASSIGN:
        2: 5430:                settings.slab_reassign = true;
        2: 5431:                break;
        -: 5432:            case SLAB_AUTOMOVE:
        1: 5433:                if (subopts_value == NULL) {
    #####: 5434:                    settings.slab_automove = 1;
    #####: 5435:                    break;
        -: 5436:                }
        2: 5437:                settings.slab_automove = atoi(subopts_value);
        1: 5438:                if (settings.slab_automove < 0 || settings.slab_automove > 2) {
    #####: 5439:                    fprintf(stderr, "slab_automove must be between 0 and 2\n");
    #####: 5440:                    return 1;
        -: 5441:                }
        -: 5442:                break;
        -: 5443:            case TAIL_REPAIR_TIME:
    #####: 5444:                if (subopts_value == NULL) {
    #####: 5445:                    fprintf(stderr, "Missing numeric argument for tail_repair_time\n");
    #####: 5446:                    return 1;
        -: 5447:                }
    #####: 5448:                settings.tail_repair_time = atoi(subopts_value);
    #####: 5449:                if (settings.tail_repair_time < 10) {
    #####: 5450:                    fprintf(stderr, "Cannot set tail_repair_time to less than 10 seconds\n");
    #####: 5451:                    return 1;
        -: 5452:                }
        -: 5453:                break;
        -: 5454:            case HASH_ALGORITHM:
    #####: 5455:                if (subopts_value == NULL) {
    #####: 5456:                    fprintf(stderr, "Missing hash_algorithm argument\n");
    #####: 5457:                    return 1;
        -: 5458:                };
    #####: 5459:                if (strcmp(subopts_value, "jenkins") == 0) {
        -: 5460:                    hash_type = JENKINS_HASH;
    #####: 5461:                } else if (strcmp(subopts_value, "murmur3") == 0) {
        -: 5462:                    hash_type = MURMUR3_HASH;
        -: 5463:                } else {
    #####: 5464:                    fprintf(stderr, "Unknown hash_algorithm option (jenkins, murmur3)\n");
    #####: 5465:                    return 1;
        -: 5466:                }
        -: 5467:                break;
        -: 5468:            case LRU_CRAWLER:
        -: 5469:                start_lru_crawler = true;
        -: 5470:                break;
        -: 5471:            case LRU_CRAWLER_SLEEP:
    #####: 5472:                if (subopts_value == NULL) {
    #####: 5473:                    fprintf(stderr, "Missing lru_crawler_sleep value\n");
    #####: 5474:                    return 1;
        -: 5475:                }
    #####: 5476:                settings.lru_crawler_sleep = atoi(subopts_value);
    #####: 5477:                if (settings.lru_crawler_sleep > 1000000 || settings.lru_crawler_sleep < 0) {
    #####: 5478:                    fprintf(stderr, "LRU crawler sleep must be between 0 and 1 second\n");
    #####: 5479:                    return 1;
        -: 5480:                }
        -: 5481:                break;
        -: 5482:            case LRU_CRAWLER_TOCRAWL:
    #####: 5483:                if (subopts_value == NULL) {
    #####: 5484:                    fprintf(stderr, "Missing lru_crawler_tocrawl value\n");
    #####: 5485:                    return 1;
        -: 5486:                }
    #####: 5487:                if (!safe_strtoul(subopts_value, &tocrawl)) {
    #####: 5488:                    fprintf(stderr, "lru_crawler_tocrawl takes a numeric 32bit value\n");
    #####: 5489:                    return 1;
        -: 5490:                }
    #####: 5491:                settings.lru_crawler_tocrawl = tocrawl;
    #####: 5492:                break;
        -: 5493:            case LRU_MAINTAINER:
        3: 5494:                start_lru_maintainer = true;
        3: 5495:                break;
        -: 5496:            case HOT_LRU_PCT:
    #####: 5497:                if (subopts_value == NULL) {
    #####: 5498:                    fprintf(stderr, "Missing hot_lru_pct argument\n");
    #####: 5499:                    return 1;
        -: 5500:                };
    #####: 5501:                settings.hot_lru_pct = atoi(subopts_value);
    #####: 5502:                if (settings.hot_lru_pct < 1 || settings.hot_lru_pct >= 80) {
    #####: 5503:                    fprintf(stderr, "hot_lru_pct must be > 1 and < 80\n");
    #####: 5504:                    return 1;
        -: 5505:                }
        -: 5506:                break;
        -: 5507:            case WARM_LRU_PCT:
    #####: 5508:                if (subopts_value == NULL) {
    #####: 5509:                    fprintf(stderr, "Missing warm_lru_pct argument\n");
    #####: 5510:                    return 1;
        -: 5511:                };
    #####: 5512:                settings.warm_lru_pct = atoi(subopts_value);
    #####: 5513:                if (settings.warm_lru_pct < 1 || settings.warm_lru_pct >= 80) {
    #####: 5514:                    fprintf(stderr, "warm_lru_pct must be > 1 and < 80\n");
    #####: 5515:                    return 1;
        -: 5516:                }
        -: 5517:                break;
        -: 5518:            case NOEXP_NOEVICT:
        1: 5519:                settings.expirezero_does_not_evict = true;
        1: 5520:                break;
        -: 5521:            default:
    #####: 5522:                printf("Illegal suboption \"%s\"\n", subopts_value);
    #####: 5523:                return 1;
        -: 5524:            }
        -: 5525:
        -: 5526:            }
        5: 5527:            free(subopts_orig);
        5: 5528:            break;
        -: 5529:        default:
    #####: 5530:            fprintf(stderr, "Illegal argument \"%c\"\n", c);
    #####: 5531:            return 1;
        -: 5532:        }
        -: 5533:    }
        -: 5534:
       84: 5535:    if (settings.lru_maintainer_thread && settings.hot_lru_pct + settings.warm_lru_pct > 80) {
    #####: 5536:        fprintf(stderr, "hot_lru_pct + warm_lru_pct cannot be more than 80%% combined\n");
    #####: 5537:        exit(EX_USAGE);
        -: 5538:    }
        -: 5539:
       84: 5540:    if (hash_init(hash_type) != 0) {
    #####: 5541:        fprintf(stderr, "Failed to initialize hash_algorithm!\n");
    #####: 5542:        exit(EX_USAGE);
        -: 5543:    }
        -: 5544:
        -: 5545:    /*
        -: 5546:     * Use one workerthread to serve each UDP port if the user specified
        -: 5547:     * multiple ports
        -: 5548:     */
       84: 5549:    if (settings.inter != NULL && strchr(settings.inter, ',')) {
    #####: 5550:        settings.num_threads_per_udp = 1;
        -: 5551:    } else {
       84: 5552:        settings.num_threads_per_udp = settings.num_threads;
        -: 5553:    }
        -: 5554:
       84: 5555:    if (settings.sasl) {
    #####: 5556:        if (!protocol_specified) {
    #####: 5557:            settings.binding_protocol = binary_prot;
        -: 5558:        } else {
    #####: 5559:            if (settings.binding_protocol != binary_prot) {
    #####: 5560:                fprintf(stderr, "ERROR: You cannot allow the ASCII protocol while using SASL.\n");
    #####: 5561:                exit(EX_USAGE);
        -: 5562:            }
        -: 5563:        }
        -: 5564:    }
        -: 5565:
       84: 5566:    if (tcp_specified && !udp_specified) {
        3: 5567:        settings.udpport = settings.port;
       81: 5568:    } else if (udp_specified && !tcp_specified) {
        3: 5569:        settings.port = settings.udpport;
        -: 5570:    }
        -: 5571:
       84: 5572:    if (maxcore != 0) {
        -: 5573:        struct rlimit rlim_new;
        -: 5574:        /*
        -: 5575:         * First try raising to infinity; if that fails, try bringing
        -: 5576:         * the soft limit to the hard.
        -: 5577:         */
    #####: 5578:        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {
    #####: 5579:            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;
    #####: 5580:            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {
        -: 5581:                /* failed. try raising just to the old max */
    #####: 5582:                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;
    #####: 5583:                (void)setrlimit(RLIMIT_CORE, &rlim_new);
        -: 5584:            }
        -: 5585:        }
        -: 5586:        /*
        -: 5587:         * getrlimit again to see what we ended up with. Only fail if
        -: 5588:         * the soft limit ends up 0, because then no core files will be
        -: 5589:         * created at all.
        -: 5590:         */
        -: 5591:
    #####: 5592:        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {
    #####: 5593:            fprintf(stderr, "failed to ensure corefile creation\n");
    #####: 5594:            exit(EX_OSERR);
        -: 5595:        }
        -: 5596:    }
        -: 5597:
        -: 5598:    /*
        -: 5599:     * If needed, increase rlimits to allow as many connections
        -: 5600:     * as needed.
        -: 5601:     */
        -: 5602:
       84: 5603:    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {
    #####: 5604:        fprintf(stderr, "failed to getrlimit number of files\n");
    #####: 5605:        exit(EX_OSERR);
        -: 5606:    } else {
       84: 5607:        rlim.rlim_cur = settings.maxconns;
       84: 5608:        rlim.rlim_max = settings.maxconns;
       84: 5609:        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {
    #####: 5610:            fprintf(stderr, "failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\n");
    #####: 5611:            exit(EX_OSERR);
        -: 5612:        }
        -: 5613:    }
        -: 5614:
        -: 5615:    /* lose root privileges if we have them */
       84: 5616:    if (getuid() == 0 || geteuid() == 0) {
    #####: 5617:        if (username == 0 || *username == '\0') {
    #####: 5618:            fprintf(stderr, "can't run as root without the -u switch\n");
    #####: 5619:            exit(EX_USAGE);
        -: 5620:        }
    #####: 5621:        if ((pw = getpwnam(username)) == 0) {
    #####: 5622:            fprintf(stderr, "can't find the user %s to switch to\n", username);
    #####: 5623:            exit(EX_NOUSER);
        -: 5624:        }
    #####: 5625:        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {
    #####: 5626:            fprintf(stderr, "failed to assume identity of user %s\n", username);
    #####: 5627:            exit(EX_OSERR);
        -: 5628:        }
        -: 5629:    }
        -: 5630:
        -: 5631:    /* Initialize Sasl if -S was specified */
        -: 5632:    if (settings.sasl) {
        -: 5633:        init_sasl();
        -: 5634:    }
        -: 5635:
        -: 5636:    /* daemonize if requested */
        -: 5637:    /* if we want to ensure our ability to dump core, don't chdir to / */
       84: 5638:    if (do_daemonize) {
        2: 5639:        if (sigignore(SIGHUP) == -1) {
    #####: 5640:            perror("Failed to ignore SIGHUP");
        -: 5641:        }
        2: 5642:        if (daemonize(maxcore, settings.verbose) == -1) {
    #####: 5643:            fprintf(stderr, "failed to daemon() in order to daemonize\n");
    #####: 5644:            exit(EXIT_FAILURE);
        -: 5645:        }
        -: 5646:    }
        -: 5647:
        -: 5648:    /* lock paged memory if needed */
       83: 5649:    if (lock_memory) {
        -: 5650:#ifdef HAVE_MLOCKALL
    #####: 5651:        int res = mlockall(MCL_CURRENT | MCL_FUTURE);
    #####: 5652:        if (res != 0) {
    #####: 5653:            fprintf(stderr, "warning: -k invalid, mlockall() failed: %s\n",
    #####: 5654:                    strerror(errno));
        -: 5655:        }
        -: 5656:#else
        -: 5657:        fprintf(stderr, "warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\n");
        -: 5658:#endif
        -: 5659:    }
        -: 5660:
        -: 5661:    /* initialize main thread libevent instance */
       83: 5662:    main_base = event_init();
        -: 5663:
        -: 5664:    /* initialize other stuff */
       83: 5665:    stats_init();
       83: 5666:    assoc_init(settings.hashpower_init);
       83: 5667:    conn_init();
       83: 5668:    slabs_init(settings.maxbytes, settings.factor, preallocate);
        -: 5669:
        -: 5670:    /*
        -: 5671:     * ignore SIGPIPE signals; we can use errno == EPIPE if we
        -: 5672:     * need that information
        -: 5673:     */
       83: 5674:    if (sigignore(SIGPIPE) == -1) {
    #####: 5675:        perror("failed to ignore SIGPIPE; sigaction");
    #####: 5676:        exit(EX_OSERR);
        -: 5677:    }
        -: 5678:    /* start up worker threads if MT mode */
       83: 5679:    memcached_thread_init(settings.num_threads, main_base);
        -: 5680:
       83: 5681:    if (start_assoc_maintenance_thread() == -1) {
    #####: 5682:        exit(EXIT_FAILURE);
        -: 5683:    }
        -: 5684:
       83: 5685:    if (start_lru_crawler && start_item_crawler_thread() != 0) {
    #####: 5686:        fprintf(stderr, "Failed to enable LRU crawler thread\n");
    #####: 5687:        exit(EXIT_FAILURE);
        -: 5688:    }
        -: 5689:
       83: 5690:    if (start_lru_maintainer && start_lru_maintainer_thread() != 0) {
    #####: 5691:        fprintf(stderr, "Failed to enable LRU maintainer thread\n");
    #####: 5692:        return 1;
        -: 5693:    }
        -: 5694:
       85: 5695:    if (settings.slab_reassign &&
        2: 5696:        start_slab_maintenance_thread() == -1) {
    #####: 5697:        exit(EXIT_FAILURE);
        -: 5698:    }
        -: 5699:
        -: 5700:    /* initialise clock event */
       83: 5701:    clock_handler(0, 0, 0);
        -: 5702:
        -: 5703:    /* create unix mode sockets after dropping privileges */
       83: 5704:    if (settings.socketpath != NULL) {
        2: 5705:        errno = 0;
        2: 5706:        if (server_socket_unix(settings.socketpath,settings.access)) {
    #####: 5707:            vperror("failed to listen on UNIX socket: %s", settings.socketpath);
    #####: 5708:            exit(EX_OSERR);
        -: 5709:        }
        -: 5710:    }
        -: 5711:
        -: 5712:    /* create the listening socket, bind it, and init */
       83: 5713:    if (settings.socketpath == NULL) {
       81: 5714:        const char *portnumber_filename = getenv("MEMCACHED_PORT_FILENAME");
        -: 5715:        char temp_portnumber_filename[PATH_MAX];
       81: 5716:        FILE *portnumber_file = NULL;
        -: 5717:
       81: 5718:        if (portnumber_filename != NULL) {
        -: 5719:            snprintf(temp_portnumber_filename,
        -: 5720:                     sizeof(temp_portnumber_filename),
        -: 5721:                     "%s.lck", portnumber_filename);
        -: 5722:
       14: 5723:            portnumber_file = fopen(temp_portnumber_filename, "a");
       14: 5724:            if (portnumber_file == NULL) {
    #####: 5725:                fprintf(stderr, "Failed to open \"%s\": %s\n",
    #####: 5726:                        temp_portnumber_filename, strerror(errno));
        -: 5727:            }
        -: 5728:        }
        -: 5729:
       81: 5730:        errno = 0;
       81: 5731:        if (settings.port && server_sockets(settings.port, tcp_transport,
        -: 5732:                                           portnumber_file)) {
        1: 5733:            vperror("failed to listen on TCP port %d", settings.port);
        1: 5734:            exit(EX_OSERR);
        -: 5735:        }
        -: 5736:
        -: 5737:        /*
        -: 5738:         * initialization order: first create the listening sockets
        -: 5739:         * (may need root on low ports), then drop root if needed,
        -: 5740:         * then daemonise if needed, then init libevent (in some cases
        -: 5741:         * descriptors created by libevent wouldn't survive forking).
        -: 5742:         */
        -: 5743:
        -: 5744:        /* create the UDP listening socket and bind it */
       80: 5745:        errno = 0;
       80: 5746:        if (settings.udpport && server_sockets(settings.udpport, udp_transport,
        -: 5747:                                              portnumber_file)) {
    #####: 5748:            vperror("failed to listen on UDP port %d", settings.udpport);
    #####: 5749:            exit(EX_OSERR);
        -: 5750:        }
        -: 5751:
       80: 5752:        if (portnumber_file) {
       14: 5753:            fclose(portnumber_file);
       14: 5754:            rename(temp_portnumber_filename, portnumber_filename);
        -: 5755:        }
        -: 5756:    }
        -: 5757:
        -: 5758:    /* Give the sockets a moment to open. I know this is dumb, but the error
        -: 5759:     * is only an advisory.
        -: 5760:     */
       82: 5761:    usleep(1000);
       82: 5762:    if (stats.curr_conns + stats.reserved_fds >= settings.maxconns - 1) {
    #####: 5763:        fprintf(stderr, "Maxconns setting is too low, use -c to increase.\n");
    #####: 5764:        exit(EXIT_FAILURE);
        -: 5765:    }
        -: 5766:
       82: 5767:    if (pid_file != NULL) {
        1: 5768:        save_pid(pid_file);
        -: 5769:    }
        -: 5770:
        -: 5771:    /* Drop privileges no longer needed */
        -: 5772:    drop_privileges();
        -: 5773:
        -: 5774:    /* enter the event loop */
       82: 5775:    if (event_base_loop(main_base, 0) != 0) {
    #####: 5776:        retval = EXIT_FAILURE;
        -: 5777:    }
        -: 5778:
    #####: 5779:    stop_assoc_maintenance_thread();
        -: 5780:
        -: 5781:    /* remove the PID file if we're a daemon */
    #####: 5782:    if (do_daemonize)
    #####: 5783:        remove_pidfile(pid_file);
        -: 5784:    /* Clean up strdup() call for bind() address */
    #####: 5785:    if (settings.inter)
    #####: 5786:      free(settings.inter);
    #####: 5787:    if (l_socket)
    #####: 5788:      free(l_socket);
    #####: 5789:    if (u_socket)
    #####: 5790:      free(u_socket);
        -: 5791:
    #####: 5792:    return retval;
        -: 5793:}
